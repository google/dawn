#include <metal_stdlib>
using namespace metal;

template<typename T, size_t N>
struct tint_array {
  const constant T& operator[](size_t i) const constant { return elements[i]; }
  device T& operator[](size_t i) device { return elements[i]; }
  const device T& operator[](size_t i) const device { return elements[i]; }
  thread T& operator[](size_t i) thread { return elements[i]; }
  const thread T& operator[](size_t i) const thread { return elements[i]; }
  threadgroup T& operator[](size_t i) threadgroup { return elements[i]; }
  const threadgroup T& operator[](size_t i) const threadgroup { return elements[i]; }
  T elements[N];
};

struct tint_packed_vec3_u32_array_element {
  /* 0x0000 */ packed_uint3 packed;
  /* 0x000c */ tint_array<int8_t, 4> tint_pad;
};

struct S_packed_vec3 {
  /* 0x0000 */ packed_uint3 a;
  /* 0x000c */ uint b;
  /* 0x0010 */ tint_array<tint_packed_vec3_u32_array_element, 4> c;
};

struct S {
  uint3 a;
  uint b;
  tint_array<uint3, 4> c;
};

struct tint_module_vars_struct {
  const constant S_packed_vec3* ubuffer;
  device S_packed_vec3* sbuffer;
  threadgroup S_packed_vec3* wbuffer;
};

struct tint_symbol_1 {
  S_packed_vec3 tint_symbol;
};

void tint_store_array_packed_vec3_1(threadgroup tint_array<tint_packed_vec3_u32_array_element, 4>* const to, tint_array<uint3, 4> value) {
  (*to)[0u].packed = packed_uint3(value[0u]);
  (*to)[1u].packed = packed_uint3(value[1u]);
  (*to)[2u].packed = packed_uint3(value[2u]);
  (*to)[3u].packed = packed_uint3(value[3u]);
}

void tint_store_array_packed_vec3(threadgroup S_packed_vec3* const to, S value) {
  (*to).a = packed_uint3(value.a);
  (*to).b = value.b;
  tint_store_array_packed_vec3_1((&(*to).c), value.c);
}

void tint_store_and_preserve_padding_1(device tint_array<tint_packed_vec3_u32_array_element, 4>* const target, tint_array<uint3, 4> value_param) {
  {
    uint v = 0u;
    v = 0u;
    while(true) {
      uint const v_1 = v;
      if ((v_1 >= 4u)) {
        break;
      }
      (*target)[v_1].packed = packed_uint3(value_param[v_1]);
      {
        v = (v_1 + 1u);
      }
      continue;
    }
  }
}

void tint_store_and_preserve_padding(device S_packed_vec3* const target, S value_param) {
  (*target).a = packed_uint3(value_param.a);
  (*target).b = value_param.b;
  tint_store_and_preserve_padding_1((&(*target).c), value_param.c);
}

tint_array<uint3, 4> tint_load_array_packed_vec3_1(device tint_array<tint_packed_vec3_u32_array_element, 4>* const from) {
  return tint_array<uint3, 4>{uint3((*from)[0u].packed), uint3((*from)[1u].packed), uint3((*from)[2u].packed), uint3((*from)[3u].packed)};
}

S tint_load_struct_packed_vec3_1(device S_packed_vec3* const from) {
  uint3 const v_2 = uint3((*from).a);
  uint const v_3 = (*from).b;
  return S{.a=v_2, .b=v_3, .c=tint_load_array_packed_vec3_1((&(*from).c))};
}

tint_array<uint3, 4> tint_load_array_packed_vec3(const constant tint_array<tint_packed_vec3_u32_array_element, 4>* const from) {
  return tint_array<uint3, 4>{uint3((*from)[0u].packed), uint3((*from)[1u].packed), uint3((*from)[2u].packed), uint3((*from)[3u].packed)};
}

S tint_load_struct_packed_vec3(const constant S_packed_vec3* const from) {
  uint3 const v_4 = uint3((*from).a);
  uint const v_5 = (*from).b;
  return S{.a=v_4, .b=v_5, .c=tint_load_array_packed_vec3((&(*from).c))};
}

void foo_inner(uint tint_local_index, tint_module_vars_struct tint_module_vars) {
  if ((tint_local_index < 1u)) {
    (*tint_module_vars.wbuffer).a = packed_uint3(uint3(0u));
    (*tint_module_vars.wbuffer).b = 0u;
  }
  {
    uint v_6 = 0u;
    v_6 = tint_local_index;
    while(true) {
      uint const v_7 = v_6;
      if ((v_7 >= 4u)) {
        break;
      }
      (*tint_module_vars.wbuffer).c[v_7].packed = packed_uint3(uint3(0u));
      {
        v_6 = (v_7 + 1u);
      }
      continue;
    }
  }
  threadgroup_barrier(mem_flags::mem_threadgroup);
  S const u = tint_load_struct_packed_vec3(tint_module_vars.ubuffer);
  S const s = tint_load_struct_packed_vec3_1(tint_module_vars.sbuffer);
  S const w = tint_load_struct_packed_vec3_1(tint_module_vars.sbuffer);
  tint_store_and_preserve_padding(tint_module_vars.sbuffer, S{});
  tint_store_array_packed_vec3(tint_module_vars.wbuffer, S{});
}

[[max_total_threads_per_threadgroup(1)]]
kernel void foo(uint tint_local_index [[thread_index_in_threadgroup]], const constant S_packed_vec3* ubuffer [[buffer(0)]], device S_packed_vec3* sbuffer [[buffer(1)]], threadgroup tint_symbol_1* v_8 [[threadgroup(0)]]) {
  tint_module_vars_struct const tint_module_vars = tint_module_vars_struct{.ubuffer=ubuffer, .sbuffer=sbuffer, .wbuffer=(&(*v_8).tint_symbol)};
  foo_inner(tint_local_index, tint_module_vars);
}
