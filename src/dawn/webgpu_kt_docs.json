{
  "_comment": "Note: This documentation was generated using AI and may contain errors. Please refer to source code and documentation for the Web (JS) and C versions of WebGPU for more accurate information.",
  "bitflags": [
    {
      "doc": "Defines the valid usages for a buffer.",
      "entries": [
        {
          "doc": "No usage is specified.",
          "name": "none"
        },
        {
          "doc": "Allows the buffer to be mapped for reading.",
          "name": "map_read"
        },
        {
          "doc": "Allows the buffer to be mapped for writing.",
          "name": "map_write"
        },
        {
          "doc": "Allows the buffer to be the source of a copy operation.",
          "name": "copy_src"
        },
        {
          "doc": "Allows the buffer to be the destination of a copy operation.",
          "name": "copy_dst"
        },
        {
          "doc": "Allows the buffer to be used as an index buffer.",
          "name": "index"
        },
        {
          "doc": "Allows the buffer to be used as a vertex buffer.",
          "name": "vertex"
        },
        {
          "doc": "Allows the buffer to be used as a uniform buffer.",
          "name": "uniform"
        },
        {
          "doc": "Allows the buffer to be used as a storage buffer.",
          "name": "storage"
        },
        {
          "doc": "Allows the buffer to be used for indirect draw or dispatch calls.",
          "name": "indirect"
        },
        {
          "doc": "Allows the buffer to be used as the destination for a query resolve operation.",
          "name": "query_resolve"
        }
      ],
      "name": "buffer_usage"
    },
    {
      "doc": "A bitmask that controls which color channels are written to a render target.",
      "entries": [
        {
          "doc": "No color channels are written.",
          "name": "none"
        },
        {
          "doc": "The red channel is written.",
          "name": "red"
        },
        {
          "doc": "The green channel is written.",
          "name": "green"
        },
        {
          "doc": "The blue channel is written.",
          "name": "blue"
        },
        {
          "doc": "The alpha channel is written.",
          "name": "alpha"
        },
        {
          "doc": "All color channels are written.",
          "name": "all",
          "value_combination": ["red", "green", "blue", "alpha"]
        }
      ],
      "name": "color_write_mask"
    },
    {
      "doc": "Specifies the access mode for a buffer mapping.",
      "entries": [
        {
          "doc": "No access mode is specified.",
          "name": "none"
        },
        {
          "doc": "Read-only access.",
          "name": "read"
        },
        {
          "doc": "Write-only access.",
          "name": "write"
        }
      ],
      "name": "map_mode"
    },
    {
      "doc": "A bitmask that specifies the shader stages where a resource is accessible.",
      "entries": [
        {
          "doc": "No shader stage is specified.",
          "name": "none"
        },
        {
          "doc": "The vertex shader stage.",
          "name": "vertex"
        },
        {
          "doc": "The fragment shader stage.",
          "name": "fragment"
        },
        {
          "doc": "The compute shader stage.",
          "name": "compute"
        }
      ],
      "name": "shader_stage"
    },
    {
      "doc": "Defines the valid usages for a texture.",
      "entries": [
        {
          "doc": "No usage is specified.",
          "name": "none"
        },
        {
          "doc": "Allows the texture to be the source of a copy operation.",
          "name": "copy_src"
        },
        {
          "doc": "Allows the texture to be the destination of a copy operation.",
          "name": "copy_dst"
        },
        {
          "doc": "Allows the texture to be sampled in a shader.",
          "name": "texture_binding"
        },
        {
          "doc": "Allows the texture to be used as a storage texture.",
          "name": "storage_binding"
        },
        {
          "doc": "Allows the texture to be used as a render attachment.",
          "name": "render_attachment"
        }
      ],
      "name": "texture_usage"
    }
  ],
  "callbacks": [
    {
      "args": [
        {
          "doc": "The status of the map operation.",
          "name": "status",
          "type": "enum.map_async_status"
        },
        {
          "doc": "An optional message providing more details on the status.",
          "name": "message",
          "passed_with_ownership": false,
          "type": "out_string"
        }
      ],
      "doc": "A callback function for asynchronous buffer mapping.",
      "name": "buffer_map",
      "style": "callback_mode"
    },
    {
      "args": [
        {
          "doc": "The status of the compilation info request.",
          "name": "status",
          "type": "enum.compilation_info_request_status"
        },
        {
          "doc": "A structure containing the compilation messages.",
          "name": "compilation_info",
          "passed_with_ownership": false,
          "pointer": "immutable",
          "type": "struct.compilation_info"
        }
      ],
      "doc": "A callback function for asynchronous shader compilation info requests.",
      "name": "compilation_info",
      "style": "callback_mode"
    },
    {
      "args": [
        {
          "doc": "The status of the pipeline creation.",
          "name": "status",
          "type": "enum.create_pipeline_async_status"
        },
        {
          "doc": "The created compute pipeline, or `NULL` on failure.",
          "name": "pipeline",
          "passed_with_ownership": true,
          "type": "object.compute_pipeline"
        },
        {
          "doc": "An optional message providing more details on the status.",
          "name": "message",
          "type": "out_string"
        }
      ],
      "doc": "A callback function for asynchronous compute pipeline creation.",
      "name": "create_compute_pipeline_async",
      "style": "callback_mode"
    },
    {
      "args": [
        {
          "doc": "The status of the pipeline creation.",
          "name": "status",
          "type": "enum.create_pipeline_async_status"
        },
        {
          "doc": "The created render pipeline, or `NULL` on failure.",
          "name": "pipeline",
          "passed_with_ownership": true,
          "type": "object.render_pipeline"
        },
        {
          "doc": "An optional message providing more details on the status.",
          "name": "message",
          "type": "out_string"
        }
      ],
      "doc": "A callback function for asynchronous render pipeline creation.",
      "name": "create_render_pipeline_async",
      "style": "callback_mode"
    },
    {
      "args": [
        {
          "doc": "A pointer to the device that was lost.",
          "name": "device",
          "passed_with_ownership": false,
          "pointer": "immutable",
          "type": "object.device"
        },
        {
          "doc": "The reason for the device loss.",
          "name": "reason",
          "type": "enum.device_lost_reason"
        },
        {
          "doc": "An optional message providing more details on the device loss.",
          "name": "message",
          "passed_with_ownership": false,
          "type": "out_string"
        }
      ],
      "doc": "A callback function for handling device loss events.",
      "name": "device_lost",
      "style": "callback_mode"
    },
    {
      "args": [
        {
          "doc": "The status of the pop operation.",
          "name": "status",
          "type": "enum.pop_error_scope_status"
        },
        {
          "doc": "The type of error captured, or @ref WGPUErrorType_NoError if none.",
          "name": "type",
          "type": "enum.error_type"
        },
        {
          "doc": "The error message, if an error was captured.",
          "name": "message",
          "passed_with_ownership": false,
          "type": "out_string"
        }
      ],
      "doc": "A callback function for asynchronous error scope popping.",
      "name": "pop_error_scope",
      "style": "callback_mode"
    },
    {
      "args": [
        {
          "doc": "The status of the queue work.",
          "name": "status",
          "type": "enum.queue_work_done_status"
        },
        {
          "doc": "An optional message providing more details on the status.",
          "name": "message",
          "passed_with_ownership": false,
          "type": "out_string"
        }
      ],
      "doc": "A callback function for monitoring the completion of work submitted to a queue.",
      "name": "queue_work_done",
      "style": "callback_mode"
    },
    {
      "args": [
        {
          "doc": "The status of the adapter request.",
          "name": "status",
          "type": "enum.request_adapter_status"
        },
        {
          "doc": "The requested adapter, or `NULL` if none was found.",
          "name": "adapter",
          "passed_with_ownership": true,
          "type": "object.adapter"
        },
        {
          "doc": "An optional message providing more details on the status.",
          "name": "message",
          "passed_with_ownership": false,
          "type": "out_string"
        }
      ],
      "doc": "A callback function for asynchronous adapter requests.",
      "name": "request_adapter",
      "style": "callback_mode"
    },
    {
      "args": [
        {
          "doc": "The status of the device request.",
          "name": "status",
          "type": "enum.request_device_status"
        },
        {
          "doc": "The requested device, or `NULL` on failure.",
          "name": "device",
          "passed_with_ownership": true,
          "type": "object.device"
        },
        {
          "doc": "An optional message providing more details on the status.",
          "name": "message",
          "passed_with_ownership": false,
          "type": "out_string"
        }
      ],
      "doc": "A callback function for asynchronous device requests.",
      "name": "request_device",
      "style": "callback_mode"
    },
    {
      "args": [
        {
          "doc": "The device on which the error occurred.",
          "name": "device",
          "passed_with_ownership": false,
          "pointer": "immutable",
          "type": "object.device"
        },
        {
          "doc": "The type of the error.",
          "name": "type",
          "type": "enum.error_type"
        },
        {
          "doc": "The error message.",
          "name": "message",
          "passed_with_ownership": false,
          "type": "out_string"
        }
      ],
      "doc": "A callback function for handling uncaptured errors.",
      "name": "uncaptured_error",
      "style": "immediate"
    }
  ],
  "constants": [
    {
      "doc": "A sentinel value indicating that the array layer count is not specified and should be inferred.",
      "name": "array_layer_count_undefined",
      "value": "uint32_max"
    },
    {
      "doc": "A sentinel value indicating that the copy stride for a texture or buffer operation is not specified.",
      "name": "copy_stride_undefined",
      "value": "uint32_max"
    },
    {
      "doc": "A sentinel value indicating that no depth clear value is provided.",
      "name": "depth_clear_value_undefined",
      "value": "nan"
    },
    {
      "doc": "A sentinel value indicating that a depth slice is not specified, often defaulting to 0.",
      "name": "depth_slice_undefined",
      "value": "uint32_max"
    },
    {
      "doc": "A sentinel value for 32-bit unsigned integer limits, indicating that no specific limit is requested.",
      "name": "limit_u32_undefined",
      "value": "uint32_max"
    },
    {
      "doc": "A sentinel value for 64-bit unsigned integer limits, indicating that no specific limit is requested.",
      "name": "limit_u64_undefined",
      "value": "uint64_max"
    },
    {
      "doc": "A sentinel value indicating that the mip level count is not specified and should be inferred.",
      "name": "mip_level_count_undefined",
      "value": "uint32_max"
    },
    {
      "doc": "A sentinel value indicating that a query set index is not specified.",
      "name": "query_set_index_undefined",
      "value": "uint32_max"
    },
    {
      "doc": "A sentinel value for @ref WGPUStringView to indicate a null-terminated string.",
      "name": "strlen",
      "value": "usize_max"
    },
    {
      "doc": "A sentinel value used in mapping operations to indicate the range extends to the end of the buffer.",
      "name": "whole_map_size",
      "value": "usize_max"
    },
    {
      "doc": "A sentinel value indicating a size that extends to the end of a resource.",
      "name": "whole_size",
      "value": "uint64_max"
    }
  ],
  "copyright": "Copyright 2019-2023 WebGPU-Native developers\n\nSPDX-License-Identifier: BSD-3-Clause\n",
  "doc": "This document specifies the WebGPU API for native platforms, defining a standard `webgpu.h`\nheader. It provides a C-compatible interface that mirrors the behavior of the WebGPU\nJavaScript specification, ensuring consistent graphics programming across web and native\nenvironments. For detailed semantics, refer to the official W3C WebGPU specification.\n",
  "enum_prefix": 0,
  "enums": [
    {
      "doc": "Describes the physical characteristics of a graphics adapter.",
      "entries": [
        null,
        {
          "doc": "A separate, dedicated graphics card.",
          "name": "discrete_GPU"
        },
        {
          "doc": "A GPU integrated with the CPU.",
          "name": "integrated_GPU"
        },
        {
          "doc": "A software-based rendering engine.",
          "name": "CPU"
        },
        {
          "doc": "The adapter type is unknown.",
          "name": "unknown"
        }
      ],
      "name": "adapter_type"
    },
    {
      "doc": "Defines how texture coordinates outside the [0, 1] range are handled.",
      "entries": [
        {
          "doc": "Indicates that no address mode is specified.",
          "name": "undefined"
        },
        {
          "doc": "Clamps coordinates to the edge of the texture.",
          "name": "clamp_to_edge"
        },
        {
          "doc": "Repeats the texture in a tiling pattern.",
          "name": "repeat"
        },
        {
          "doc": "Repeats the texture, mirroring it at each integer boundary.",
          "name": "mirror_repeat"
        }
      ],
      "name": "address_mode"
    },
    {
      "doc": "Specifies the underlying graphics API used by the WebGPU implementation.",
      "entries": [
        {
          "doc": "Indicates that no backend type is specified.",
          "name": "undefined"
        },
        {
          "doc": "A null backend with no-op rendering.",
          "name": "null"
        },
        {
          "doc": "The WebGPU backend.",
          "name": "WebGPU"
        },
        {
          "doc": "Direct3D 11 backend.",
          "name": "D3D11"
        },
        {
          "doc": "Direct3D 12 backend.",
          "name": "D3D12"
        },
        {
          "doc": "Apple Metal backend.",
          "name": "metal"
        },
        {
          "doc": "Vulkan backend.",
          "name": "vulkan"
        },
        {
          "doc": "OpenGL backend.",
          "name": "openGL"
        },
        {
          "doc": "OpenGL ES backend.",
          "name": "openGLES"
        }
      ],
      "name": "backend_type"
    },
    {
      "doc": "Defines the factors used in blend operations.",
      "entries": [
        {
          "doc": "Indicates that no blend factor is specified.",
          "name": "undefined"
        },
        {
          "doc": "The blend factor is `(0, 0, 0, 0)`.",
          "name": "zero"
        },
        {
          "doc": "The blend factor is `(1, 1, 1, 1)`.",
          "name": "one"
        },
        {
          "doc": "The blend factor is `(Rs, Gs, Bs, As)`.",
          "name": "src"
        },
        {
          "doc": "The blend factor is `(1-Rs, 1-Gs, 1-Bs, 1-As)`.",
          "name": "one_minus_src"
        },
        {
          "doc": "The blend factor is `(As, As, As, As)`.",
          "name": "src_alpha"
        },
        {
          "doc": "The blend factor is `(1-As, 1-As, 1-As, 1-As)`.",
          "name": "one_minus_src_alpha"
        },
        {
          "doc": "The blend factor is `(Rd, Gd, Bd, Ad)`.",
          "name": "dst"
        },
        {
          "doc": "The blend factor is `(1-Rd, 1-Gd, 1-Bd, 1-Ad)`.",
          "name": "one_minus_dst"
        },
        {
          "doc": "The blend factor is `(Ad, Ad, Ad, Ad)`.",
          "name": "dst_alpha"
        },
        {
          "doc": "The blend factor is `(1-Ad, 1-Ad, 1-Ad, 1-Ad)`.",
          "name": "one_minus_dst_alpha"
        },
        {
          "doc": "The blend factor is `(f, f, f, 1)` where `f = min(As, 1 - Ad)`.",
          "name": "src_alpha_saturated"
        },
        {
          "doc": "The blend factor is the blend constant `(Rc, Gc, Bc, Ac)`.",
          "name": "constant"
        },
        {
          "doc": "The blend factor is `(1-Rc, 1-Gc, 1-Bc, 1-Ac)`.",
          "name": "one_minus_constant"
        },
        {
          "doc": "The blend factor is the second source color `(Rs1, Gs1, Bs1, As1)`. Requires @ref WGPUFeatureName_DualSourceBlending.",
          "name": "src1"
        },
        {
          "doc": "The blend factor is `(1-Rs1, 1-Gs1, 1-Bs1, 1-As1)`. Requires @ref WGPUFeatureName_DualSourceBlending.",
          "name": "one_minus_src1"
        },
        {
          "doc": "The blend factor is `(As1, As1, As1, As1)`. Requires @ref WGPUFeatureName_DualSourceBlending.",
          "name": "src1_alpha"
        },
        {
          "doc": "The blend factor is `(1-As1, 1-As1, 1-As1, 1-As1)`. Requires @ref WGPUFeatureName_DualSourceBlending.",
          "name": "one_minus_src1_alpha"
        }
      ],
      "name": "blend_factor"
    },
    {
      "doc": "Defines the operation to perform when blending color values.",
      "entries": [
        {
          "doc": "Indicates that no blend operation is specified.",
          "name": "undefined"
        },
        {
          "doc": "The result is the sum of the source and destination.",
          "name": "add"
        },
        {
          "doc": "The result is the destination subtracted from the source.",
          "name": "subtract"
        },
        {
          "doc": "The result is the source subtracted from the destination.",
          "name": "reverse_subtract"
        },
        {
          "doc": "The result is the minimum of the source and destination.",
          "name": "min"
        },
        {
          "doc": "The result is the maximum of the source and destination.",
          "name": "max"
        }
      ],
      "name": "blend_operation"
    },
    {
      "doc": "Specifies the type of a buffer binding in a bind group layout.",
      "entries": [
        {
          "doc": "Indicates that this binding is not used.",
          "name": "binding_not_used"
        },
        {
          "doc": "Indicates that no buffer binding type is specified.",
          "name": "undefined"
        },
        {
          "doc": "A uniform buffer binding.",
          "name": "uniform"
        },
        {
          "doc": "A read-write storage buffer binding.",
          "name": "storage"
        },
        {
          "doc": "A read-only storage buffer binding.",
          "name": "read_only_storage"
        }
      ],
      "name": "buffer_binding_type"
    },
    {
      "doc": "Describes the current mapping state of a buffer.",
      "entries": [
        null,
        {
          "doc": "The buffer is not mapped.",
          "name": "unmapped"
        },
        {
          "doc": "The buffer is in the process of being mapped.",
          "name": "pending"
        },
        {
          "doc": "The buffer is mapped and its contents are accessible.",
          "name": "mapped"
        }
      ],
      "name": "buffer_map_state"
    },
    {
      "doc": "Controls how and when asynchronous operation callbacks are invoked.",
      "entries": [
        null,
        {
          "doc": "Callbacks fire only within a call to @ref wgpuInstanceWaitAny.",
          "name": "wait_any_only"
        },
        {
          "doc": "Callbacks may fire within @ref wgpuInstanceWaitAny or @ref wgpuInstanceProcessEvents.",
          "name": "allow_process_events"
        },
        {
          "doc": "Callbacks may fire spontaneously on any thread when the operation completes.",
          "name": "allow_spontaneous"
        }
      ],
      "name": "callback_mode"
    },
    {
      "doc": "Defines the comparison function used for depth and stencil tests.",
      "entries": [
        {
          "doc": "Indicates that no compare function is specified.",
          "name": "undefined"
        },
        {
          "doc": "The comparison never passes.",
          "name": "never"
        },
        {
          "doc": "The comparison passes if the new value is less than the existing value.",
          "name": "less"
        },
        {
          "doc": "The comparison passes if the new value is equal to the existing value.",
          "name": "equal"
        },
        {
          "doc": "The comparison passes if the new value is less than or equal to the existing value.",
          "name": "less_equal"
        },
        {
          "doc": "The comparison passes if the new value is greater than the existing value.",
          "name": "greater"
        },
        {
          "doc": "The comparison passes if the new value is not equal to the existing value.",
          "name": "not_equal"
        },
        {
          "doc": "The comparison passes if the new value is greater than or equal to the existing value.",
          "name": "greater_equal"
        },
        {
          "doc": "The comparison always passes.",
          "name": "always"
        }
      ],
      "name": "compare_function"
    },
    {
      "doc": "Indicates the status of a shader compilation info request.",
      "entries": [
        null,
        {
          "doc": "The request was successful.",
          "name": "success"
        },
        {
          "doc": "Indicates the request for compilation info was cancelled. This typically occurs if the shader module is destroyed or the device is lost before the info could be generated.",
          "name": "callback_cancelled"
        }
      ],
      "name": "compilation_info_request_status"
    },
    {
      "doc": "Specifies the severity of a shader compilation message.",
      "entries": [
        null,
        {
          "doc": "A compilation error.",
          "name": "error"
        },
        {
          "doc": "A compilation warning.",
          "name": "warning"
        },
        {
          "doc": "An informational message.",
          "name": "info"
        }
      ],
      "name": "compilation_message_type"
    },
    {
      "doc": "Defines how component values are remapped when sampling a texture.",
      "entries": [
        {
          "doc": "Indicates no value is passed for this argument. See @ref SentinelValues.",
          "name": "undefined"
        },
        {
          "doc": "Force its value to 0.\n",
          "name": "zero"
        },
        {
          "doc": "Force its value to 1.\n",
          "name": "one"
        },
        {
          "doc": "Take its value from the red channel of the texture.\n",
          "name": "r"
        },
        {
          "doc": "Take its value from the green channel of the texture.\n",
          "name": "g"
        },
        {
          "doc": "Take its value from the blue channel of the texture.\n",
          "name": "b"
        },
        {
          "doc": "Take its value from the alpha channel of the texture.\n",
          "name": "a"
        }
      ],
      "name": "component_swizzle"
    },
    {
      "doc": "Defines how the alpha channel of a surface's texture is handled during compositing.",
      "entries": [
        {
          "doc": "The implementation selects the optimal composite alpha mode.",
          "name": "auto"
        },
        {
          "doc": "The alpha channel is ignored and treated as `1.0`.",
          "name": "opaque"
        },
        {
          "doc": "Color channels are assumed to be premultiplied by the alpha channel.",
          "name": "premultiplied"
        },
        {
          "doc": "Color channels are not premultiplied by the alpha channel.",
          "name": "unpremultiplied"
        },
        {
          "doc": "The alpha compositing is handled by the system outside of WebGPU.",
          "name": "inherit"
        }
      ],
      "name": "composite_alpha_mode"
    },
    {
      "doc": "Indicates the status of an asynchronous pipeline creation request.",
      "entries": [
        null,
        {
          "doc": "Pipeline creation was successful.",
          "name": "success"
        },
        {
          "doc": "Indicates the asynchronous pipeline creation was cancelled. This happens if the device is lost or destroyed while the pipeline is being compiled.",
          "name": "callback_cancelled"
        },
        {
          "doc": "A validation error occurred during pipeline creation.",
          "name": "validation_error"
        },
        {
          "doc": "An internal error occurred during pipeline creation.",
          "name": "internal_error"
        }
      ],
      "name": "create_pipeline_async_status"
    },
    {
      "doc": "Defines which primitive faces are culled during rasterization.",
      "entries": [
        {
          "doc": "Indicates that no cull mode is specified.",
          "name": "undefined"
        },
        {
          "doc": "No faces are culled.",
          "name": "none"
        },
        {
          "doc": "Front-facing primitives are culled.",
          "name": "front"
        },
        {
          "doc": "Back-facing primitives are culled.",
          "name": "back"
        }
      ],
      "name": "cull_mode"
    },
    {
      "doc": "Specifies the reason why a device was lost.",
      "entries": [
        null,
        {
          "doc": "The reason for the device loss is unknown.",
          "name": "unknown"
        },
        {
          "doc": "The device was explicitly destroyed.",
          "name": "destroyed"
        },
        {
          "doc": "Indicates the device lost callback was cancelled. This happens if the callback is replaced or unset, or if the device is destroyed cleanly without a specific error.",
          "name": "callback_cancelled"
        },
        {
          "doc": "The device failed to be created.",
          "name": "failed_creation"
        }
      ],
      "name": "device_lost_reason"
    },
    {
      "doc": "Defines the types of errors to be captured in an error scope.",
      "entries": [
        null,
        {
          "doc": "Captures validation errors.",
          "name": "validation"
        },
        {
          "doc": "Captures out-of-memory errors.",
          "name": "out_of_memory"
        },
        {
          "doc": "Captures internal implementation errors.",
          "name": "internal"
        }
      ],
      "name": "error_filter"
    },
    {
      "doc": "Specifies the type of a WebGPU error.",
      "entries": [
        null,
        {
          "doc": "No error occurred.",
          "name": "no_error"
        },
        {
          "doc": "A validation error occurred.",
          "name": "validation"
        },
        {
          "doc": "An out-of-memory error occurred.",
          "name": "out_of_memory"
        },
        {
          "doc": "An internal implementation error occurred.",
          "name": "internal"
        },
        {
          "doc": "An unknown error occurred.",
          "name": "unknown"
        }
      ],
      "name": "error_type"
    },
    {
      "doc": "Specifies a feature level for adapter requests. See @ref WGPURequestAdapterOptions::featureLevel.",
      "entries": [
        {
          "doc": "Indicates no specific feature level is requested.",
          "name": "undefined"
        },
        {
          "doc": "`Compatibility` profile, supportable on older APIs like OpenGL ES 3.1 and Direct3D 11.",
          "name": "compatibility"
        },
        {
          "doc": "`Core` profile, requiring modern APIs like Vulkan, Metal, or Direct3D 12.",
          "name": "core"
        }
      ],
      "name": "feature_level"
    },
    {
      "doc": "An enumeration of optional features that a device may support.",
      "entries": [
        null,
        {
          "doc": "Represents the baseline set of WebGPU features and limits.",
          "name": "core_features_and_limits"
        },
        {
          "doc": "Allows disabling depth clipping.",
          "name": "depth_clip_control"
        },
        {
          "doc": "Support for @ref WGPUTextureFormat_Depth32FloatStencil8 texture format.",
          "name": "depth32_float_stencil8"
        },
        {
          "doc": "Support for BC compressed texture formats.",
          "name": "texture_compression_BC"
        },
        {
          "doc": "Support for sliced 3D BC compressed texture formats.",
          "name": "texture_compression_BC_sliced_3D"
        },
        {
          "doc": "Support for ETC2 compressed texture formats.",
          "name": "texture_compression_ETC2"
        },
        {
          "doc": "Support for ASTC compressed texture formats.",
          "name": "texture_compression_ASTC"
        },
        {
          "doc": "Support for sliced 3D ASTC compressed texture formats.",
          "name": "texture_compression_ASTC_sliced_3D"
        },
        {
          "doc": "Support for timestamp queries.",
          "name": "timestamp_query"
        },
        {
          "doc": "Support for `firstInstance` parameter in indirect draw calls.",
          "name": "indirect_first_instance"
        },
        {
          "doc": "Support for 16-bit floating-point types in WGSL.",
          "name": "shader_f16"
        },
        {
          "doc": "Support for rendering to @ref WGPUTextureFormat_RG11B10Ufloat textures.",
          "name": "RG11B10_ufloat_renderable"
        },
        {
          "doc": "Support for using @ref WGPUTextureFormat_BGRA8Unorm as a storage texture.",
          "name": "BGRA8_unorm_storage"
        },
        {
          "doc": "Allows filtering of 32-bit float textures.",
          "name": "float32_filterable"
        },
        {
          "doc": "Allows blending on 32-bit float render targets.",
          "name": "float32_blendable"
        },
        {
          "doc": "Allows usage of clip distances in shaders.",
          "name": "clip_distances"
        },
        {
          "doc": "Allows blending with a second source color output from a fragment shader.",
          "name": "dual_source_blending"
        },
        {
          "doc": "Support for shader subgroup operations.",
          "name": "subgroups"
        },
        {
          "doc": "A set of additional texture formats.",
          "name": "texture_formats_tier_1"
        },
        {
          "doc": "A larger set of additional texture formats.",
          "name": "texture_formats_tier_2"
        },
        {
          "doc": "Enables the primitive index feature, allowing fragment shaders to read the index of the geometric primitive being rasterized.",
          "name": "primitive_index"
        },
        {
          "doc": "Enables the creation of texture views with a defined component swizzle, allowing the remapping of the R, G, B, and A components during sampling.",
          "name": "texture_component_swizzle"
        }
      ],
      "name": "feature_name"
    },
    {
      "doc": "Defines the texture filtering mode for magnification and minification.",
      "entries": [
        {
          "doc": "Indicates that no filter mode is specified.",
          "name": "undefined"
        },
        {
          "doc": "Nearest-neighbor filtering.",
          "name": "nearest"
        },
        {
          "doc": "Linear filtering.",
          "name": "linear"
        }
      ],
      "name": "filter_mode"
    },
    {
      "doc": "Defines which vertex winding order corresponds to the front face of a primitive.",
      "entries": [
        {
          "doc": "Indicates that no front face winding order is specified.",
          "name": "undefined"
        },
        {
          "doc": "Counter-clockwise winding order.",
          "name": "CCW"
        },
        {
          "doc": "Clockwise winding order.",
          "name": "CW"
        }
      ],
      "name": "front_face"
    },
    {
      "doc": "Specifies the data type of an index buffer.",
      "entries": [
        {
          "doc": "Indicates that no index format is specified.",
          "name": "undefined"
        },
        {
          "doc": "16-bit unsigned integer indices.",
          "name": "uint16"
        },
        {
          "doc": "32-bit unsigned integer indices.",
          "name": "uint32"
        }
      ],
      "name": "index_format"
    },
    {
      "doc": "An enumeration of optional features that an instance may support.",
      "entries": [
        null,
        {
          "doc": "Enables the use of `timeoutNS \u003e 0` with @ref wgpuInstanceWaitAny.",
          "name": "timed_wait_any"
        },
        {
          "doc": "Enables passing SPIR-V shaders to @ref wgpuDeviceCreateShaderModule via @ref WGPUShaderSourceSPIRV.",
          "name": "shader_source_SPIRV"
        },
        {
          "doc": "Allows creating multiple devices from a single adapter.",
          "name": "multiple_devices_per_adapter"
        }
      ],
      "name": "instance_feature_name"
    },
    {
      "doc": "Defines the operation to perform on a render attachment at the beginning of a pass.",
      "entries": [
        {
          "doc": "Indicates that no load operation is specified.",
          "name": "undefined"
        },
        {
          "doc": "Loads the existing contents of the attachment.",
          "name": "load"
        },
        {
          "doc": "Clears the attachment to a specified value.",
          "name": "clear"
        }
      ],
      "name": "load_op"
    },
    {
      "doc": "Indicates the status of an asynchronous buffer map operation.",
      "entries": [
        null,
        {
          "doc": "The buffer was successfully mapped.",
          "name": "success"
        },
        {
          "doc": "Indicates the buffer mapping operation was cancelled. This commonly happens if the buffer is unmapped or destroyed before the asynchronous map request completes.",
          "name": "callback_cancelled"
        },
        {
          "doc": "An error occurred while mapping the buffer.",
          "name": "error"
        },
        {
          "doc": "The map operation was aborted.",
          "name": "aborted"
        }
      ],
      "name": "map_async_status"
    },
    {
      "doc": "Defines the filtering mode used between mipmap levels.",
      "entries": [
        {
          "doc": "Indicates that no mipmap filter mode is specified.",
          "name": "undefined"
        },
        {
          "doc": "Nearest-neighbor filtering between mipmaps.",
          "name": "nearest"
        },
        {
          "doc": "Linear filtering between mipmaps.",
          "name": "linear"
        }
      ],
      "name": "mipmap_filter_mode"
    },
    {
      "doc": "Represents a boolean value that can also be undefined.",
      "entries": [
        {
          "doc": "The boolean value `false`.",
          "name": "false"
        },
        {
          "doc": "The boolean value `true`.",
          "name": "true"
        },
        {
          "doc": "No boolean value is specified.",
          "name": "undefined"
        }
      ],
      "name": "optional_bool"
    },
    {
      "doc": "Indicates the status of a pop error scope operation.",
      "entries": [
        null,
        {
          "doc": "The error scope was popped successfully.",
          "name": "success"
        },
        {
          "doc": "Indicates the error scope pop operation was cancelled. This typically happens if the device is lost or destroyed while waiting for the scope to close.",
          "name": "callback_cancelled"
        },
        {
          "doc": "An error occurred, such as popping from an empty stack.",
          "name": "error"
        }
      ],
      "name": "pop_error_scope_status"
    },
    {
      "doc": "Defines the power consumption preference when requesting an adapter.",
      "entries": [
        {
          "doc": "No power preference is specified.",
          "name": "undefined"
        },
        {
          "doc": "Prefers a power-saving adapter.",
          "name": "low_power"
        },
        {
          "doc": "Prefers a high-performance adapter.",
          "name": "high_performance"
        }
      ],
      "name": "power_preference"
    },
    {
      "doc": "Defines standard color spaces for surfaces.",
      "entries": [
        null,
        {
          "doc": "The sRGB color space.",
          "name": "SRGB"
        },
        {
          "doc": "The Display-P3 color space.",
          "name": "display_p3"
        }
      ],
      "name": "predefined_color_space"
    },
    {
      "doc": "Defines the behavior of frame presentation for a surface.",
      "entries": [
        {
          "doc": "The present mode is not specified; uses a default.",
          "name": "undefined"
        },
        {
          "doc": "V-sync enabled, presents frames in a first-in, first-out queue.",
          "name": "fifo"
        },
        {
          "doc": "A relaxed version of FIFO that may allow tearing to reduce latency.",
          "name": "fifo_relaxed"
        },
        {
          "doc": "Presents frames immediately, which may result in tearing.",
          "name": "immediate"
        },
        {
          "doc": "V-sync enabled, presents the most recently completed frame, discarding older ones.",
          "name": "mailbox"
        }
      ],
      "name": "present_mode"
    },
    {
      "doc": "Defines how vertices are interpreted to form geometric primitives.",
      "entries": [
        {
          "doc": "Indicates that no primitive topology is specified.",
          "name": "undefined"
        },
        {
          "doc": "A list of individual points.",
          "name": "point_list"
        },
        {
          "doc": "A list of separate lines.",
          "name": "line_list"
        },
        {
          "doc": "A connected strip of lines.",
          "name": "line_strip"
        },
        {
          "doc": "A list of separate triangles.",
          "name": "triangle_list"
        },
        {
          "doc": "A connected strip of triangles.",
          "name": "triangle_strip"
        }
      ],
      "name": "primitive_topology"
    },
    {
      "doc": "Specifies the type of a query set.",
      "entries": [
        null,
        {
          "doc": "An occlusion query, which counts fragments that pass depth and stencil tests.",
          "name": "occlusion"
        },
        {
          "doc": "A timestamp query, which records GPU timestamps.",
          "name": "timestamp"
        }
      ],
      "name": "query_type"
    },
    {
      "doc": "Indicates the status of a queue work done callback.",
      "entries": [
        null,
        {
          "doc": "The work was completed successfully.",
          "name": "success"
        },
        {
          "doc": "Indicates the work done notification was cancelled. This occurs if the device is lost or the queue is destroyed before the submitted work finishes.",
          "name": "callback_cancelled"
        },
        {
          "doc": "A deterministic error occurred.",
          "name": "error"
        }
      ],
      "name": "queue_work_done_status"
    },
    {
      "doc": "Indicates the status of an adapter request.",
      "entries": [
        null,
        {
          "doc": "An adapter was successfully found.",
          "name": "success"
        },
        {
          "doc": "Indicates the adapter request was cancelled. This happens if the instance is destroyed or the request is explicitly aborted before an adapter is found.",
          "name": "callback_cancelled"
        },
        {
          "doc": "No suitable adapter was found.",
          "name": "unavailable"
        },
        {
          "doc": "An error occurred during the adapter request.",
          "name": "error"
        }
      ],
      "name": "request_adapter_status"
    },
    {
      "doc": "Indicates the status of a device request.",
      "entries": [
        null,
        {
          "doc": "The device was successfully created.",
          "name": "success"
        },
        {
          "doc": "Indicates the device request was cancelled. This happens if the adapter becomes invalid or the instance is destroyed before the device is created.",
          "name": "callback_cancelled"
        },
        {
          "doc": "An error occurred during device creation.",
          "name": "error"
        }
      ],
      "name": "request_device_status"
    },
    {
      "doc": "Identifies the type of a structure in an extensible structure chain.",
      "entries": [
        null,
        {
          "doc": "A SPIR-V shader source.",
          "name": "shader_source_SPIRV"
        },
        {
          "doc": "A WGSL shader source.",
          "name": "shader_source_WGSL"
        },
        {
          "doc": "An extension for specifying max draw count in a render pass.",
          "name": "render_pass_max_draw_count"
        },
        {
          "doc": "A surface created from a CAMetalLayer.",
          "name": "surface_source_metal_layer"
        },
        {
          "doc": "A surface created from a Windows HWND.",
          "name": "surface_source_windows_HWND"
        },
        {
          "doc": "A surface created from an Xlib Window.",
          "name": "surface_source_xlib_window"
        },
        {
          "doc": "A surface created from a Wayland wl_surface.",
          "name": "surface_source_wayland_surface"
        },
        {
          "doc": "A surface created from an Android ANativeWindow.",
          "name": "surface_source_android_native_window"
        },
        {
          "doc": "A surface created from an XCB window.",
          "name": "surface_source_XCB_window"
        },
        {
          "doc": "An extension for surface color management.",
          "name": "surface_color_management"
        },
        {
          "doc": "An extension for WebXR interop adapter options.",
          "name": "request_adapter_WebXR_options"
        }
      ],
      "name": "s_type"
    },
    {
      "doc": "Specifies the type of a sampler binding in a bind group layout.",
      "entries": [
        {
          "doc": "Indicates that this binding is not used.",
          "name": "binding_not_used"
        },
        {
          "doc": "Indicates that no sampler binding type is specified.",
          "name": "undefined"
        },
        {
          "doc": "A filtering sampler.",
          "name": "filtering"
        },
        {
          "doc": "A non-filtering sampler.",
          "name": "non_filtering"
        },
        {
          "doc": "A comparison sampler for depth textures.",
          "name": "comparison"
        }
      ],
      "name": "sampler_binding_type"
    },
    {
      "doc": "A status code returned synchronously from an operation.",
      "entries": [
        null,
        {
          "doc": "The operation was successful.",
          "name": "success"
        },
        {
          "doc": "An error occurred.",
          "name": "error"
        }
      ],
      "name": "status"
    },
    {
      "doc": "Defines the operation to perform on the stencil buffer.",
      "entries": [
        {
          "doc": "Indicates that no stencil operation is specified.",
          "name": "undefined"
        },
        {
          "doc": "Keeps the current stencil value.",
          "name": "keep"
        },
        {
          "doc": "Sets the stencil value to zero.",
          "name": "zero"
        },
        {
          "doc": "Replaces the stencil value with the reference value.",
          "name": "replace"
        },
        {
          "doc": "Inverts the bits of the stencil value.",
          "name": "invert"
        },
        {
          "doc": "Increments the stencil value, clamping at the maximum.",
          "name": "increment_clamp"
        },
        {
          "doc": "Decrements the stencil value, clamping at zero.",
          "name": "decrement_clamp"
        },
        {
          "doc": "Increments the stencil value, wrapping on overflow.",
          "name": "increment_wrap"
        },
        {
          "doc": "Decrements the stencil value, wrapping on underflow.",
          "name": "decrement_wrap"
        }
      ],
      "name": "stencil_operation"
    },
    {
      "doc": "Defines the access mode for a storage texture binding.",
      "entries": [
        {
          "doc": "Indicates that this binding is not used.",
          "name": "binding_not_used"
        },
        {
          "doc": "Indicates that no storage texture access mode is specified.",
          "name": "undefined"
        },
        {
          "doc": "Write-only access.",
          "name": "write_only"
        },
        {
          "doc": "Read-only access.",
          "name": "read_only"
        },
        {
          "doc": "Read-write access.",
          "name": "read_write"
        }
      ],
      "name": "storage_texture_access"
    },
    {
      "doc": "Defines the operation to perform on a render attachment at the end of a pass.",
      "entries": [
        {
          "doc": "Indicates that no store operation is specified.",
          "name": "undefined"
        },
        {
          "doc": "Stores the contents of the attachment.",
          "name": "store"
        },
        {
          "doc": "Discards the contents of the attachment.",
          "name": "discard"
        }
      ],
      "name": "store_op"
    },
    {
      "doc": "Status codes for retrieving the current texture from a surface.",
      "entries": [
        null,
        {
          "doc": "The texture was acquired successfully and is optimal for presentation.",
          "name": "success_optimal"
        },
        {
          "doc": "The texture was acquired successfully but is suboptimal for presentation; reconfiguration may be needed.",
          "name": "success_suboptimal"
        },
        {
          "doc": "The operation timed out while acquiring the texture.",
          "name": "timeout"
        },
        {
          "doc": "The surface configuration is outdated and must be reconfigured.",
          "name": "outdated"
        },
        {
          "doc": "The surface has been lost and must be recreated.",
          "name": "lost"
        },
        {
          "doc": "A deterministic error occurred, such as the surface not being configured.",
          "name": "error"
        }
      ],
      "name": "surface_get_current_texture_status"
    },
    {
      "doc": "Specifies which aspect of a texture is being referenced.",
      "entries": [
        {
          "doc": "Indicates that no texture aspect is specified.",
          "name": "undefined"
        },
        {
          "doc": "All aspects of the texture.",
          "name": "all"
        },
        {
          "doc": "The stencil aspect of a depth-stencil texture.",
          "name": "stencil_only"
        },
        {
          "doc": "The depth aspect of a depth-stencil texture.",
          "name": "depth_only"
        }
      ],
      "name": "texture_aspect"
    },
    {
      "doc": "Defines the dimensionality of a texture.",
      "entries": [
        {
          "doc": "Indicates that no texture dimension is specified.",
          "name": "undefined"
        },
        {
          "doc": "A one-dimensional texture.",
          "name": "1D"
        },
        {
          "doc": "A two-dimensional texture.",
          "name": "2D"
        },
        {
          "doc": "A three-dimensional texture.",
          "name": "3D"
        }
      ],
      "name": "texture_dimension"
    },
    {
      "doc": "An enumeration of all supported texture formats.",
      "entries": [
        {
          "doc": "Indicates that no texture format is specified.",
          "name": "undefined"
        },
        {
          "doc": "8-bit unsigned normalized red channel format.",
          "name": "R8_unorm"
        },
        {
          "doc": "8-bit signed normalized red channel format.",
          "name": "R8_snorm"
        },
        {
          "doc": "8-bit unsigned integer red channel format.",
          "name": "R8_uint"
        },
        {
          "doc": "8-bit signed integer red channel format.",
          "name": "R8_sint"
        },
        {
          "doc": "16-bit unsigned normalized red channel format.",
          "name": "R16_unorm"
        },
        {
          "doc": "16-bit signed normalized red channel format.",
          "name": "R16_snorm"
        },
        {
          "doc": "16-bit unsigned integer red channel format.",
          "name": "R16_uint"
        },
        {
          "doc": "16-bit signed integer red channel format.",
          "name": "R16_sint"
        },
        {
          "doc": "16-bit float red channel format.",
          "name": "R16_float"
        },
        {
          "doc": "Two-component 16-bit unsigned normalized format.",
          "name": "RG8_unorm"
        },
        {
          "doc": "Two-component 16-bit signed normalized format.",
          "name": "RG8_snorm"
        },
        {
          "doc": "Two-component 16-bit unsigned integer format.",
          "name": "RG8_uint"
        },
        {
          "doc": "Two-component 16-bit signed integer format.",
          "name": "RG8_sint"
        },
        {
          "doc": "32-bit float red channel format.",
          "name": "R32_float"
        },
        {
          "doc": "32-bit unsigned integer red channel format.",
          "name": "R32_uint"
        },
        {
          "doc": "32-bit signed integer red channel format.",
          "name": "R32_sint"
        },
        {
          "doc": "Two-component 32-bit unsigned normalized format.",
          "name": "RG16_unorm"
        },
        {
          "doc": "Two-component 32-bit signed normalized format.",
          "name": "RG16_snorm"
        },
        {
          "doc": "Two-component 32-bit unsigned integer format.",
          "name": "RG16_uint"
        },
        {
          "doc": "Two-component 32-bit signed integer format.",
          "name": "RG16_sint"
        },
        {
          "doc": "Two-component 32-bit float format.",
          "name": "RG16_float"
        },
        {
          "doc": "Four-component 32-bit unsigned normalized format.",
          "name": "RGBA8_unorm"
        },
        {
          "doc": "Four-component 32-bit sRGB unsigned normalized format.",
          "name": "RGBA8_unorm_srgb"
        },
        {
          "doc": "Four-component 32-bit signed normalized format.",
          "name": "RGBA8_snorm"
        },
        {
          "doc": "Four-component 32-bit unsigned integer format.",
          "name": "RGBA8_uint"
        },
        {
          "doc": "Four-component 32-bit signed integer format.",
          "name": "RGBA8_sint"
        },
        {
          "doc": "Four-component 32-bit unsigned normalized format with blue channel first.",
          "name": "BGRA8_unorm"
        },
        {
          "doc": "Four-component 32-bit sRGB unsigned normalized format with blue channel first.",
          "name": "BGRA8_unorm_srgb"
        },
        {
          "doc": "Packed 32-bit format with 10-bit R, G, B and 2-bit A unsigned integer components.",
          "name": "RGB10_A2_uint"
        },
        {
          "doc": "Packed 32-bit format with 10-bit R, G, B and 2-bit A unsigned normalized components.",
          "name": "RGB10_A2_unorm"
        },
        {
          "doc": "Packed 32-bit format with 11-bit R, G and 10-bit B unsigned float components.",
          "name": "RG11_B10_ufloat"
        },
        {
          "doc": "Packed 32-bit format with 9-bit R, G, B mantissas and a shared 5-bit exponent.",
          "name": "RGB9_E5_ufloat"
        },
        {
          "doc": "Two-component 64-bit float format.",
          "name": "RG32_float"
        },
        {
          "doc": "Two-component 64-bit unsigned integer format.",
          "name": "RG32_uint"
        },
        {
          "doc": "Two-component 64-bit signed integer format.",
          "name": "RG32_sint"
        },
        {
          "doc": "Four-component 64-bit unsigned normalized format.",
          "name": "RGBA16_unorm"
        },
        {
          "doc": "Four-component 64-bit signed normalized format.",
          "name": "RGBA16_snorm"
        },
        {
          "doc": "Four-component 64-bit unsigned integer format.",
          "name": "RGBA16_uint"
        },
        {
          "doc": "Four-component 64-bit signed integer format.",
          "name": "RGBA16_sint"
        },
        {
          "doc": "Four-component 64-bit float format.",
          "name": "RGBA16_float"
        },
        {
          "doc": "Four-component 128-bit float format.",
          "name": "RGBA32_float"
        },
        {
          "doc": "Four-component 128-bit unsigned integer format.",
          "name": "RGBA32_uint"
        },
        {
          "doc": "Four-component 128-bit signed integer format.",
          "name": "RGBA32_sint"
        },
        {
          "doc": "8-bit stencil format.",
          "name": "stencil8"
        },
        {
          "doc": "16-bit unsigned normalized depth format.",
          "name": "depth16_unorm"
        },
        {
          "doc": "A depth format with at least 24 bits.",
          "name": "depth24_plus"
        },
        {
          "doc": "A packed depth-stencil format with at least 24 bits for depth and 8 for stencil.",
          "name": "depth24_plus_stencil8"
        },
        {
          "doc": "32-bit float depth format.",
          "name": "depth32_float"
        },
        {
          "doc": "32-bit float depth and 8-bit stencil format.",
          "name": "depth32_float_stencil8"
        },
        {
          "doc": "BC1 compressed RGBA unsigned normalized format.",
          "name": "BC1_RGBA_unorm"
        },
        {
          "doc": "BC1 compressed RGBA sRGB unsigned normalized format.",
          "name": "BC1_RGBA_unorm_srgb"
        },
        {
          "doc": "BC2 compressed RGBA unsigned normalized format.",
          "name": "BC2_RGBA_unorm"
        },
        {
          "doc": "BC2 compressed RGBA sRGB unsigned normalized format.",
          "name": "BC2_RGBA_unorm_srgb"
        },
        {
          "doc": "BC3 compressed RGBA unsigned normalized format.",
          "name": "BC3_RGBA_unorm"
        },
        {
          "doc": "BC3 compressed RGBA sRGB unsigned normalized format.",
          "name": "BC3_RGBA_unorm_srgb"
        },
        {
          "doc": "BC4 compressed single-channel unsigned normalized format.",
          "name": "BC4_R_unorm"
        },
        {
          "doc": "BC4 compressed single-channel signed normalized format.",
          "name": "BC4_R_snorm"
        },
        {
          "doc": "BC5 compressed two-channel unsigned normalized format.",
          "name": "BC5_RG_unorm"
        },
        {
          "doc": "BC5 compressed two-channel signed normalized format.",
          "name": "BC5_RG_snorm"
        },
        {
          "doc": "BC6H compressed RGB unsigned float format.",
          "name": "BC6H_RGB_ufloat"
        },
        {
          "doc": "BC6H compressed RGB signed float format.",
          "name": "BC6H_RGB_float"
        },
        {
          "doc": "BC7 compressed RGBA unsigned normalized format.",
          "name": "BC7_RGBA_unorm"
        },
        {
          "doc": "BC7 compressed RGBA sRGB unsigned normalized format.",
          "name": "BC7_RGBA_unorm_srgb"
        },
        {
          "doc": "ETC2 compressed RGB8 unsigned normalized format.",
          "name": "ETC2_RGB8_unorm"
        },
        {
          "doc": "ETC2 compressed RGB8 sRGB unsigned normalized format.",
          "name": "ETC2_RGB8_unorm_srgb"
        },
        {
          "doc": "ETC2 compressed RGB8A1 unsigned normalized format.",
          "name": "ETC2_RGB8A1_unorm"
        },
        {
          "doc": "ETC2 compressed RGB8A1 sRGB unsigned normalized format.",
          "name": "ETC2_RGB8A1_unorm_srgb"
        },
        {
          "doc": "ETC2 compressed RGBA8 unsigned normalized format.",
          "name": "ETC2_RGBA8_unorm"
        },
        {
          "doc": "ETC2 compressed RGBA8 sRGB unsigned normalized format.",
          "name": "ETC2_RGBA8_unorm_srgb"
        },
        {
          "doc": "EAC compressed R11 unsigned normalized format.",
          "name": "EAC_R11_unorm"
        },
        {
          "doc": "EAC compressed R11 signed normalized format.",
          "name": "EAC_R11_snorm"
        },
        {
          "doc": "EAC compressed RG11 unsigned normalized format.",
          "name": "EAC_RG11_unorm"
        },
        {
          "doc": "EAC compressed RG11 signed normalized format.",
          "name": "EAC_RG11_snorm"
        },
        {
          "doc": "ASTC compressed 4x4 unsigned normalized format.",
          "name": "ASTC_4x4_unorm"
        },
        {
          "doc": "ASTC compressed 4x4 sRGB unsigned normalized format.",
          "name": "ASTC_4x4_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 5x4 unsigned normalized format.",
          "name": "ASTC_5x4_unorm"
        },
        {
          "doc": "ASTC compressed 5x4 sRGB unsigned normalized format.",
          "name": "ASTC_5x4_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 5x5 unsigned normalized format.",
          "name": "ASTC_5x5_unorm"
        },
        {
          "doc": "ASTC compressed 5x5 sRGB unsigned normalized format.",
          "name": "ASTC_5x5_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 6x5 unsigned normalized format.",
          "name": "ASTC_6x5_unorm"
        },
        {
          "doc": "ASTC compressed 6x5 sRGB unsigned normalized format.",
          "name": "ASTC_6x5_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 6x6 unsigned normalized format.",
          "name": "ASTC_6x6_unorm"
        },
        {
          "doc": "ASTC compressed 6x6 sRGB unsigned normalized format.",
          "name": "ASTC_6x6_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 8x5 unsigned normalized format.",
          "name": "ASTC_8x5_unorm"
        },
        {
          "doc": "ASTC compressed 8x5 sRGB unsigned normalized format.",
          "name": "ASTC_8x5_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 8x6 unsigned normalized format.",
          "name": "ASTC_8x6_unorm"
        },
        {
          "doc": "ASTC compressed 8x6 sRGB unsigned normalized format.",
          "name": "ASTC_8x6_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 8x8 unsigned normalized format.",
          "name": "ASTC_8x8_unorm"
        },
        {
          "doc": "ASTC compressed 8x8 sRGB unsigned normalized format.",
          "name": "ASTC_8x8_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 10x5 unsigned normalized format.",
          "name": "ASTC_10x5_unorm"
        },
        {
          "doc": "ASTC compressed 10x5 sRGB unsigned normalized format.",
          "name": "ASTC_10x5_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 10x6 unsigned normalized format.",
          "name": "ASTC_10x6_unorm"
        },
        {
          "doc": "ASTC compressed 10x6 sRGB unsigned normalized format.",
          "name": "ASTC_10x6_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 10x8 unsigned normalized format.",
          "name": "ASTC_10x8_unorm"
        },
        {
          "doc": "ASTC compressed 10x8 sRGB unsigned normalized format.",
          "name": "ASTC_10x8_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 10x10 unsigned normalized format.",
          "name": "ASTC_10x10_unorm"
        },
        {
          "doc": "ASTC compressed 10x10 sRGB unsigned normalized format.",
          "name": "ASTC_10x10_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 12x10 unsigned normalized format.",
          "name": "ASTC_12x10_unorm"
        },
        {
          "doc": "ASTC compressed 12x10 sRGB unsigned normalized format.",
          "name": "ASTC_12x10_unorm_srgb"
        },
        {
          "doc": "ASTC compressed 12x12 unsigned normalized format.",
          "name": "ASTC_12x12_unorm"
        },
        {
          "doc": "ASTC compressed 12x12 sRGB unsigned normalized format.",
          "name": "ASTC_12x12_unorm_srgb"
        }
      ],
      "name": "texture_format"
    },
    {
      "doc": "Specifies the data type of a sampled texture in a bind group layout.",
      "entries": [
        {
          "doc": "Indicates that this binding is not used.",
          "name": "binding_not_used"
        },
        {
          "doc": "Indicates that no texture sample type is specified.",
          "name": "undefined"
        },
        {
          "doc": "A floating-point texture.",
          "name": "float"
        },
        {
          "doc": "A non-filterable floating-point texture.",
          "name": "unfilterable_float"
        },
        {
          "doc": "A depth texture.",
          "name": "depth"
        },
        {
          "doc": "A signed integer texture.",
          "name": "sint"
        },
        {
          "doc": "An unsigned integer texture.",
          "name": "uint"
        }
      ],
      "name": "texture_sample_type"
    },
    {
      "doc": "Defines the dimensionality of a texture view.",
      "entries": [
        {
          "doc": "Indicates that no texture view dimension is specified.",
          "name": "undefined"
        },
        {
          "doc": "A one-dimensional texture view.",
          "name": "1D"
        },
        {
          "doc": "A two-dimensional texture view.",
          "name": "2D"
        },
        {
          "doc": "A two-dimensional array texture view.",
          "name": "2D_array"
        },
        {
          "doc": "A cube map texture view.",
          "name": "cube"
        },
        {
          "doc": "A cube map array texture view.",
          "name": "cube_array"
        },
        {
          "doc": "A three-dimensional texture view.",
          "name": "3D"
        }
      ],
      "name": "texture_view_dimension"
    },
    {
      "doc": "Defines the tone mapping mode for a surface.",
      "entries": [
        null,
        {
          "doc": "Standard tone mapping.",
          "name": "standard"
        },
        {
          "doc": "Extended range tone mapping for HDR.",
          "name": "extended"
        }
      ],
      "name": "tone_mapping_mode"
    },
    {
      "doc": "Specifies the data format of a vertex attribute.",
      "entries": [
        null,
        {
          "doc": "Single-component, 8-bit unsigned integer.",
          "name": "uint8"
        },
        {
          "doc": "Two-component, 8-bit unsigned integer.",
          "name": "uint8x2"
        },
        {
          "doc": "Four-component, 8-bit unsigned integer.",
          "name": "uint8x4"
        },
        {
          "doc": "Single-component, 8-bit signed integer.",
          "name": "sint8"
        },
        {
          "doc": "Two-component, 8-bit signed integer.",
          "name": "sint8x2"
        },
        {
          "doc": "Four-component, 8-bit signed integer.",
          "name": "sint8x4"
        },
        {
          "doc": "Single-component, 8-bit unsigned normalized.",
          "name": "unorm8"
        },
        {
          "doc": "Two-component, 8-bit unsigned normalized.",
          "name": "unorm8x2"
        },
        {
          "doc": "Four-component, 8-bit unsigned normalized.",
          "name": "unorm8x4"
        },
        {
          "doc": "Single-component, 8-bit signed normalized.",
          "name": "snorm8"
        },
        {
          "doc": "Two-component, 8-bit signed normalized.",
          "name": "snorm8x2"
        },
        {
          "doc": "Four-component, 8-bit signed normalized.",
          "name": "snorm8x4"
        },
        {
          "doc": "Single-component, 16-bit unsigned integer.",
          "name": "uint16"
        },
        {
          "doc": "Two-component, 16-bit unsigned integer.",
          "name": "uint16x2"
        },
        {
          "doc": "Four-component, 16-bit unsigned integer.",
          "name": "uint16x4"
        },
        {
          "doc": "Single-component, 16-bit signed integer.",
          "name": "sint16"
        },
        {
          "doc": "Two-component, 16-bit signed integer.",
          "name": "sint16x2"
        },
        {
          "doc": "Four-component, 16-bit signed integer.",
          "name": "sint16x4"
        },
        {
          "doc": "Single-component, 16-bit unsigned normalized.",
          "name": "unorm16"
        },
        {
          "doc": "Two-component, 16-bit unsigned normalized.",
          "name": "unorm16x2"
        },
        {
          "doc": "Four-component, 16-bit unsigned normalized.",
          "name": "unorm16x4"
        },
        {
          "doc": "Single-component, 16-bit signed normalized.",
          "name": "snorm16"
        },
        {
          "doc": "Two-component, 16-bit signed normalized.",
          "name": "snorm16x2"
        },
        {
          "doc": "Four-component, 16-bit signed normalized.",
          "name": "snorm16x4"
        },
        {
          "doc": "Single-component, 16-bit float.",
          "name": "float16"
        },
        {
          "doc": "Two-component, 16-bit float.",
          "name": "float16x2"
        },
        {
          "doc": "Four-component, 16-bit float.",
          "name": "float16x4"
        },
        {
          "doc": "Single-component, 32-bit float.",
          "name": "float32"
        },
        {
          "doc": "Two-component, 32-bit float.",
          "name": "float32x2"
        },
        {
          "doc": "Three-component, 32-bit float.",
          "name": "float32x3"
        },
        {
          "doc": "Four-component, 32-bit float.",
          "name": "float32x4"
        },
        {
          "doc": "Single-component, 32-bit unsigned integer.",
          "name": "uint32"
        },
        {
          "doc": "Two-component, 32-bit unsigned integer.",
          "name": "uint32x2"
        },
        {
          "doc": "Three-component, 32-bit unsigned integer.",
          "name": "uint32x3"
        },
        {
          "doc": "Four-component, 32-bit unsigned integer.",
          "name": "uint32x4"
        },
        {
          "doc": "Single-component, 32-bit signed integer.",
          "name": "sint32"
        },
        {
          "doc": "Two-component, 32-bit signed integer.",
          "name": "sint32x2"
        },
        {
          "doc": "Three-component, 32-bit signed integer.",
          "name": "sint32x3"
        },
        {
          "doc": "Four-component, 32-bit signed integer.",
          "name": "sint32x4"
        },
        {
          "doc": "Packed 10-10-10-2 unsigned normalized format.",
          "name": "unorm10__10__10__2"
        },
        {
          "doc": "Four-component, 8-bit unsigned normalized format with BGRA channel order.",
          "name": "unorm8x4_B_G_R_A"
        }
      ],
      "name": "vertex_format"
    },
    {
      "doc": "Defines how frequently a vertex buffer is advanced.",
      "entries": [
        {
          "doc": "Indicates that no vertex step mode is specified.",
          "name": "undefined"
        },
        {
          "doc": "The vertex buffer is advanced for each vertex.",
          "name": "vertex"
        },
        {
          "doc": "The vertex buffer is advanced for each instance.",
          "name": "instance"
        }
      ],
      "name": "vertex_step_mode"
    },
    {
      "doc": "Status returned from a call to @ref wgpuInstanceWaitAny.",
      "entries": [
        null,
        {
          "doc": "At least one future completed successfully.",
          "name": "success"
        },
        {
          "doc": "The wait operation timed out before any futures completed.",
          "name": "timed_out"
        },
        {
          "doc": "An invalid call was made. See @ref Wait-Any for details.",
          "name": "error"
        }
      ],
      "name": "wait_status"
    },
    {
      "doc": "An enumeration of optional WGSL language features.",
      "entries": [
        null,
        {
          "doc": "Support for `readonly` and `readwrite` access qualifiers on storage textures.",
          "name": "readonly_and_readwrite_storage_textures"
        },
        {
          "doc": "Support for the `dot()` built-in function on `vec4\u003ci32\u003e` and `vec4\u003cu32\u003e` types.",
          "name": "packed4x8_integer_dot_product"
        },
        {
          "doc": "Allows passing pointers with `storage` and `uniform` address spaces as function parameters.",
          "name": "unrestricted_pointer_parameters"
        },
        {
          "doc": "Allows accessing components of composite types through pointers.",
          "name": "pointer_composite_access"
        },
        {
          "doc": "Enables the use of standard memory layout definitions for uniform buffers, relaxing strict alignment requirements to support tighter data packing.",
          "name": "uniform_buffer_standard_layout"
        },
        {
          "doc": "Enables access to the subgroup identifier within a compute shader, allowing algorithms to utilize subgroup-level parallelism.",
          "name": "subgroup_id"
        }
      ],
      "name": "WGSL_language_feature_name"
    }
  ],
  "functions": [
    {
      "args": [
        {
          "doc": "The descriptor for the instance.",
          "name": "descriptor",
          "optional": true,
          "pointer": "immutable",
          "type": "struct.instance_descriptor"
        }
      ],
      "doc": "Creates a new WebGPU instance.",
      "name": "create_instance",
      "returns": {
        "doc": "A handle to the created instance.",
        "passed_with_ownership": true,
        "type": "object.instance"
      }
    },
    {
      "args": [
        {
          "doc": "A structure to be filled with the supported features.",
          "name": "features",
          "passed_with_ownership": true,
          "pointer": "mutable",
          "type": "struct.supported_instance_features"
        }
      ],
      "doc": "Retrieves the list of features supported by the instance.",
      "name": "get_instance_features"
    },
    {
      "args": [
        {
          "doc": "A structure to be filled with the supported limits.",
          "name": "limits",
          "pointer": "mutable",
          "type": "struct.instance_limits"
        }
      ],
      "doc": "Retrieves the limits supported by the instance.",
      "name": "get_instance_limits",
      "returns": {
        "doc": "The status of the operation.",
        "type": "enum.status"
      }
    },
    {
      "args": [
        {
          "doc": "The feature to check for.",
          "name": "feature",
          "type": "enum.instance_feature_name"
        }
      ],
      "doc": "Checks if a specific feature is supported by the instance.",
      "name": "has_instance_feature",
      "returns": {
        "doc": "`true` if the feature is supported, `false` otherwise.",
        "type": "bool"
      }
    }
  ],
  "name": "webgpu",
  "objects": [
    {
      "doc": "Represents a physical graphics adapter.",
      "methods": [
        {
          "args": [
            {
              "doc": "A structure to be filled with the supported limits.",
              "name": "limits",
              "pointer": "mutable",
              "type": "struct.limits"
            }
          ],
          "doc": "Retrieves the limits supported by the adapter.",
          "name": "get_limits",
          "returns": {
            "doc": "The status of the operation.",
            "type": "enum.status"
          }
        },
        {
          "args": [
            {
              "doc": "The feature to check for.",
              "name": "feature",
              "type": "enum.feature_name"
            }
          ],
          "doc": "Checks if a specific feature is supported by the adapter.",
          "name": "has_feature",
          "returns": {
            "doc": "`true` if the feature is supported, `false` otherwise.",
            "type": "bool"
          }
        },
        {
          "args": [
            {
              "doc": "A structure to be filled with the supported features.",
              "name": "features",
              "passed_with_ownership": true,
              "pointer": "mutable",
              "type": "struct.supported_features"
            }
          ],
          "doc": "Retrieves the list of features supported by the adapter.",
          "name": "get_features"
        },
        {
          "args": [
            {
              "doc": "A structure to be filled with the adapter information.",
              "name": "info",
              "passed_with_ownership": true,
              "pointer": "mutable",
              "type": "struct.adapter_info"
            }
          ],
          "doc": "Retrieves detailed information about the adapter.",
          "name": "get_info",
          "returns": {
            "doc": "The status of the operation.",
            "type": "enum.status"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the device.",
              "name": "descriptor",
              "optional": true,
              "pointer": "immutable",
              "type": "struct.device_descriptor"
            }
          ],
          "callback": "callback.request_device",
          "doc": "Asynchronously requests a device from the adapter.",
          "name": "request_device"
        }
      ],
      "name": "adapter"
    },
    {
      "doc": "A collection of resources to be bound to a pipeline.",
      "methods": [
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "bind_group"
    },
    {
      "doc": "The layout of a bind group, defining the types of its resources.",
      "methods": [
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "bind_group_layout"
    },
    {
      "doc": "A block of memory accessible by the GPU.",
      "methods": [
        {
          "args": [
            {
              "doc": "The mapping mode (read or write).",
              "name": "mode",
              "type": "bitflag.map_mode"
            },
            {
              "doc": "The offset in bytes from the beginning of the buffer.",
              "name": "offset",
              "type": "usize"
            },
            {
              "doc": "The size in bytes of the range to map.",
              "name": "size",
              "type": "usize"
            }
          ],
          "callback": "callback.buffer_map",
          "doc": "Asynchronously maps a range of the buffer for CPU access.",
          "name": "map_async"
        },
        {
          "args": [
            {
              "doc": "The offset in bytes from the beginning of the buffer.",
              "name": "offset",
              "type": "usize"
            },
            {
              "doc": "The size in bytes of the range to get.",
              "name": "size",
              "type": "usize"
            }
          ],
          "doc": "Gets a pointer to the mapped range of the buffer.",
          "name": "get_mapped_range",
          "returns": {
            "doc": "A pointer to the mapped memory.",
            "pointer": "mutable",
            "type": "c_void"
          }
        },
        {
          "args": [
            {
              "doc": "The offset in bytes from the beginning of the buffer.",
              "name": "offset",
              "type": "usize"
            },
            {
              "doc": "The size in bytes of the range to get.",
              "name": "size",
              "type": "usize"
            }
          ],
          "doc": "Gets a read-only pointer to the mapped range of the buffer.",
          "name": "get_const_mapped_range",
          "returns": {
            "doc": "A read-only pointer to the mapped memory.",
            "pointer": "immutable",
            "type": "c_void"
          }
        },
        {
          "args": [
            {
              "doc": "The offset in bytes from the beginning of the buffer.",
              "name": "offset",
              "type": "usize"
            },
            {
              "doc": "The destination pointer.",
              "name": "data",
              "pointer": "mutable",
              "type": "c_void"
            },
            {
              "doc": "The number of bytes to read.",
              "name": "size",
              "type": "usize"
            }
          ],
          "doc": "Copies data from a mapped range into a destination pointer.",
          "name": "read_mapped_range",
          "returns": {
            "doc": "The status of the operation.",
            "type": "enum.status"
          }
        },
        {
          "args": [
            {
              "doc": "The offset in bytes from the beginning of the buffer.",
              "name": "offset",
              "type": "usize"
            },
            {
              "doc": "The source pointer.",
              "name": "data",
              "pointer": "immutable",
              "type": "c_void"
            },
            {
              "doc": "The number of bytes to write.",
              "name": "size",
              "type": "usize"
            }
          ],
          "doc": "Copies data from a source pointer into a mapped range.",
          "name": "write_mapped_range",
          "returns": {
            "doc": "The status of the operation.",
            "type": "enum.status"
          }
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        },
        {
          "doc": "Gets the allowed usages of the buffer.",
          "name": "get_usage",
          "returns": {
            "doc": "The buffer usage flags.",
            "type": "bitflag.buffer_usage"
          }
        },
        {
          "doc": "Gets the size of the buffer in bytes.",
          "name": "get_size",
          "returns": {
            "doc": "The buffer size.",
            "type": "uint64"
          }
        },
        {
          "doc": "Gets the current mapping state of the buffer.",
          "name": "get_map_state",
          "returns": {
            "doc": "The buffer map state.",
            "type": "enum.buffer_map_state"
          }
        },
        {
          "doc": "Unmaps the buffer, making it accessible to the GPU again.",
          "name": "unmap"
        },
        {
          "doc": "Destroys the buffer and releases its resources.",
          "name": "destroy"
        }
      ],
      "name": "buffer"
    },
    {
      "doc": "A recorded sequence of GPU commands.",
      "methods": [
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "command_buffer"
    },
    {
      "doc": "An object used to record GPU commands.",
      "methods": [
        {
          "args": [
            {
              "doc": "The descriptor for the command buffer.",
              "name": "descriptor",
              "optional": true,
              "pointer": "immutable",
              "type": "struct.command_buffer_descriptor"
            }
          ],
          "doc": "Finishes recording commands and creates a command buffer.",
          "name": "finish",
          "returns": {
            "doc": "The created command buffer.",
            "passed_with_ownership": true,
            "type": "object.command_buffer"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the compute pass.",
              "name": "descriptor",
              "optional": true,
              "pointer": "immutable",
              "type": "struct.compute_pass_descriptor"
            }
          ],
          "doc": "Begins recording a compute pass.",
          "name": "begin_compute_pass",
          "returns": {
            "doc": "A compute pass encoder.",
            "passed_with_ownership": true,
            "type": "object.compute_pass_encoder"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the render pass.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.render_pass_descriptor"
            }
          ],
          "doc": "Begins recording a render pass.",
          "name": "begin_render_pass",
          "returns": {
            "doc": "A render pass encoder.",
            "passed_with_ownership": true,
            "type": "object.render_pass_encoder"
          }
        },
        {
          "args": [
            {
              "doc": "The source buffer.",
              "name": "source",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the source buffer.",
              "name": "source_offset",
              "type": "uint64"
            },
            {
              "doc": "The destination buffer.",
              "name": "destination",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the destination buffer.",
              "name": "destination_offset",
              "type": "uint64"
            },
            {
              "doc": "The number of bytes to copy.",
              "name": "size",
              "type": "uint64"
            }
          ],
          "doc": "Copies data from one buffer to another.",
          "name": "copy_buffer_to_buffer"
        },
        {
          "args": [
            {
              "doc": "The source buffer information.",
              "name": "source",
              "pointer": "immutable",
              "type": "struct.texel_copy_buffer_info"
            },
            {
              "doc": "The destination texture information.",
              "name": "destination",
              "pointer": "immutable",
              "type": "struct.texel_copy_texture_info"
            },
            {
              "doc": "The size of the region to copy.",
              "name": "copy_size",
              "pointer": "immutable",
              "type": "struct.extent_3D"
            }
          ],
          "doc": "Copies data from a buffer to a texture.",
          "name": "copy_buffer_to_texture"
        },
        {
          "args": [
            {
              "doc": "The source texture information.",
              "name": "source",
              "pointer": "immutable",
              "type": "struct.texel_copy_texture_info"
            },
            {
              "doc": "The destination buffer information.",
              "name": "destination",
              "pointer": "immutable",
              "type": "struct.texel_copy_buffer_info"
            },
            {
              "doc": "The size of the region to copy.",
              "name": "copy_size",
              "pointer": "immutable",
              "type": "struct.extent_3D"
            }
          ],
          "doc": "Copies data from a texture to a buffer.",
          "name": "copy_texture_to_buffer"
        },
        {
          "args": [
            {
              "doc": "The source texture information.",
              "name": "source",
              "pointer": "immutable",
              "type": "struct.texel_copy_texture_info"
            },
            {
              "doc": "The destination texture information.",
              "name": "destination",
              "pointer": "immutable",
              "type": "struct.texel_copy_texture_info"
            },
            {
              "doc": "The size of the region to copy.",
              "name": "copy_size",
              "pointer": "immutable",
              "type": "struct.extent_3D"
            }
          ],
          "doc": "Copies data from one texture to another.",
          "name": "copy_texture_to_texture"
        },
        {
          "args": [
            {
              "doc": "The buffer to clear.",
              "name": "buffer",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the buffer.",
              "name": "offset",
              "type": "uint64"
            },
            {
              "doc": "The number of bytes to clear.",
              "name": "size",
              "type": "uint64"
            }
          ],
          "doc": "Fills a buffer with zeros.",
          "name": "clear_buffer"
        },
        {
          "args": [
            {
              "doc": "The label for the debug marker.",
              "name": "marker_label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Inserts a debug marker into the command stream.",
          "name": "insert_debug_marker"
        },
        {
          "doc": "Pops the current debug group.",
          "name": "pop_debug_group"
        },
        {
          "args": [
            {
              "doc": "The label for the debug group.",
              "name": "group_label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Pushes a new debug group.",
          "name": "push_debug_group"
        },
        {
          "args": [
            {
              "doc": "The query set to resolve.",
              "name": "query_set",
              "type": "object.query_set"
            },
            {
              "doc": "The index of the first query to resolve.",
              "name": "first_query",
              "type": "uint32"
            },
            {
              "doc": "The number of queries to resolve.",
              "name": "query_count",
              "type": "uint32"
            },
            {
              "doc": "The destination buffer.",
              "name": "destination",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the destination buffer.",
              "name": "destination_offset",
              "type": "uint64"
            }
          ],
          "doc": "Resolves the results of a query set into a buffer.",
          "name": "resolve_query_set"
        },
        {
          "args": [
            {
              "doc": "The query set to write to.",
              "name": "query_set",
              "type": "object.query_set"
            },
            {
              "doc": "The index in the query set.",
              "name": "query_index",
              "type": "uint32"
            }
          ],
          "doc": "Writes a timestamp value into a query set.",
          "name": "write_timestamp"
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "command_encoder"
    },
    {
      "doc": "An object used to record commands for a compute pass.",
      "methods": [
        {
          "args": [
            {
              "doc": "The label for the debug marker.",
              "name": "marker_label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Inserts a debug marker into the command stream.",
          "name": "insert_debug_marker"
        },
        {
          "doc": "Pops the current debug group.",
          "name": "pop_debug_group"
        },
        {
          "args": [
            {
              "doc": "The label for the debug group.",
              "name": "group_label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Pushes a new debug group.",
          "name": "push_debug_group"
        },
        {
          "args": [
            {
              "doc": "The compute pipeline to set.",
              "name": "pipeline",
              "type": "object.compute_pipeline"
            }
          ],
          "doc": "Sets the current compute pipeline.",
          "name": "set_pipeline"
        },
        {
          "args": [
            {
              "doc": "The index of the bind group.",
              "name": "group_index",
              "type": "uint32"
            },
            {
              "doc": "The bind group to set.",
              "name": "group",
              "optional": true,
              "type": "object.bind_group"
            },
            {
              "doc": "An array of dynamic offsets.",
              "name": "dynamic_offsets",
              "pointer": "immutable",
              "type": "array\u003cuint32\u003e"
            }
          ],
          "doc": "Sets a bind group for the pipeline.",
          "name": "set_bind_group"
        },
        {
          "args": [
            {
              "doc": "The number of workgroups in the X dimension.",
              "name": "workgroupCountX",
              "type": "uint32"
            },
            {
              "doc": "The number of workgroups in the Y dimension.",
              "name": "workgroupCountY",
              "type": "uint32"
            },
            {
              "doc": "The number of workgroups in the Z dimension.",
              "name": "workgroupCountZ",
              "type": "uint32"
            }
          ],
          "doc": "Dispatches a compute shader.",
          "name": "dispatch_workgroups"
        },
        {
          "args": [
            {
              "doc": "The buffer containing the dispatch parameters.",
              "name": "indirect_buffer",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the indirect buffer.",
              "name": "indirect_offset",
              "type": "uint64"
            }
          ],
          "doc": "Dispatches a compute shader with parameters from a buffer.",
          "name": "dispatch_workgroups_indirect"
        },
        {
          "doc": "Ends the compute pass.",
          "name": "end"
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "compute_pass_encoder"
    },
    {
      "doc": "A pipeline for compute operations.",
      "methods": [
        {
          "args": [
            {
              "doc": "The index of the bind group.",
              "name": "group_index",
              "type": "uint32"
            }
          ],
          "doc": "Gets the layout of a bind group for this pipeline.",
          "name": "get_bind_group_layout",
          "returns": {
            "doc": "The bind group layout.",
            "passed_with_ownership": true,
            "type": "object.bind_group_layout"
          }
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "compute_pipeline"
    },
    {
      "doc": "A logical graphics device.",
      "methods": [
        {
          "args": [
            {
              "doc": "The descriptor for the bind group.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.bind_group_descriptor"
            }
          ],
          "doc": "Creates a new bind group.",
          "name": "create_bind_group",
          "returns": {
            "doc": "The created bind group.",
            "passed_with_ownership": true,
            "type": "object.bind_group"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the bind group layout.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.bind_group_layout_descriptor"
            }
          ],
          "doc": "Creates a new bind group layout.",
          "name": "create_bind_group_layout",
          "returns": {
            "doc": "The created bind group layout.",
            "passed_with_ownership": true,
            "type": "object.bind_group_layout"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the buffer.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.buffer_descriptor"
            }
          ],
          "doc": "Creates a new buffer.",
          "name": "create_buffer",
          "returns": {
            "doc": "The created buffer, or `NULL` on failure.",
            "optional": true,
            "passed_with_ownership": true,
            "type": "object.buffer"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the command encoder.",
              "name": "descriptor",
              "optional": true,
              "pointer": "immutable",
              "type": "struct.command_encoder_descriptor"
            }
          ],
          "doc": "Creates a new command encoder.",
          "name": "create_command_encoder",
          "returns": {
            "doc": "The created command encoder.",
            "passed_with_ownership": true,
            "type": "object.command_encoder"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the compute pipeline.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.compute_pipeline_descriptor"
            }
          ],
          "doc": "Creates a new compute pipeline.",
          "name": "create_compute_pipeline",
          "returns": {
            "doc": "The created compute pipeline.",
            "passed_with_ownership": true,
            "type": "object.compute_pipeline"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the compute pipeline.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.compute_pipeline_descriptor"
            }
          ],
          "callback": "callback.create_compute_pipeline_async",
          "doc": "Asynchronously creates a new compute pipeline.",
          "name": "create_compute_pipeline_async"
        },
        {
          "args": [
            {
              "doc": "The descriptor for the pipeline layout.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.pipeline_layout_descriptor"
            }
          ],
          "doc": "Creates a new pipeline layout.",
          "name": "create_pipeline_layout",
          "returns": {
            "doc": "The created pipeline layout.",
            "passed_with_ownership": true,
            "type": "object.pipeline_layout"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the query set.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.query_set_descriptor"
            }
          ],
          "doc": "Creates a new query set.",
          "name": "create_query_set",
          "returns": {
            "doc": "The created query set.",
            "passed_with_ownership": true,
            "type": "object.query_set"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the render pipeline.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.render_pipeline_descriptor"
            }
          ],
          "callback": "callback.create_render_pipeline_async",
          "doc": "Asynchronously creates a new render pipeline.",
          "name": "create_render_pipeline_async"
        },
        {
          "args": [
            {
              "doc": "The descriptor for the render bundle encoder.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.render_bundle_encoder_descriptor"
            }
          ],
          "doc": "Creates a new render bundle encoder.",
          "name": "create_render_bundle_encoder",
          "returns": {
            "doc": "The created render bundle encoder.",
            "passed_with_ownership": true,
            "type": "object.render_bundle_encoder"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the render pipeline.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.render_pipeline_descriptor"
            }
          ],
          "doc": "Creates a new render pipeline.",
          "name": "create_render_pipeline",
          "returns": {
            "doc": "The created render pipeline.",
            "passed_with_ownership": true,
            "type": "object.render_pipeline"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the sampler.",
              "name": "descriptor",
              "optional": true,
              "pointer": "immutable",
              "type": "struct.sampler_descriptor"
            }
          ],
          "doc": "Creates a new sampler.",
          "name": "create_sampler",
          "returns": {
            "doc": "The created sampler.",
            "passed_with_ownership": true,
            "type": "object.sampler"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the shader module.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.shader_module_descriptor"
            }
          ],
          "doc": "Creates a new shader module.",
          "name": "create_shader_module",
          "returns": {
            "doc": "The created shader module.",
            "passed_with_ownership": true,
            "type": "object.shader_module"
          }
        },
        {
          "args": [
            {
              "doc": "The descriptor for the texture.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.texture_descriptor"
            }
          ],
          "doc": "Creates a new texture.",
          "name": "create_texture",
          "returns": {
            "doc": "The created texture.",
            "passed_with_ownership": true,
            "type": "object.texture"
          }
        },
        {
          "doc": "Destroys the device and releases its resources.",
          "name": "destroy"
        },
        {
          "doc": "Gets a future that completes when the device is lost.",
          "name": "get_lost_future",
          "returns": {
            "doc": "The future for the device loss event.",
            "type": "struct.future"
          }
        },
        {
          "args": [
            {
              "doc": "A structure to be filled with the supported limits.",
              "name": "limits",
              "pointer": "mutable",
              "type": "struct.limits"
            }
          ],
          "doc": "Retrieves the limits supported by the device.",
          "name": "get_limits",
          "returns": {
            "doc": "The status of the operation.",
            "type": "enum.status"
          }
        },
        {
          "args": [
            {
              "doc": "The feature to check for.",
              "name": "feature",
              "type": "enum.feature_name"
            }
          ],
          "doc": "Checks if a specific feature is supported by the device.",
          "name": "has_feature",
          "returns": {
            "doc": "`true` if the feature is supported, `false` otherwise.",
            "type": "bool"
          }
        },
        {
          "args": [
            {
              "doc": "A structure to be filled with the supported features.",
              "name": "features",
              "passed_with_ownership": true,
              "pointer": "mutable",
              "type": "struct.supported_features"
            }
          ],
          "doc": "Retrieves the list of features supported by the device.",
          "name": "get_features"
        },
        {
          "args": [
            {
              "doc": "A structure to be filled with adapter information.",
              "name": "adapter_info",
              "passed_with_ownership": true,
              "pointer": "mutable",
              "type": "struct.adapter_info"
            }
          ],
          "doc": "Retrieves information about the adapter that created this device.",
          "name": "get_adapter_info",
          "returns": {
            "doc": "The status of the operation.",
            "type": "enum.status"
          }
        },
        {
          "doc": "Gets the default queue for the device.",
          "name": "get_queue",
          "returns": {
            "doc": "The default queue.",
            "passed_with_ownership": true,
            "type": "object.queue"
          }
        },
        {
          "args": [
            {
              "doc": "The filter for the types of errors to capture.",
              "name": "filter",
              "type": "enum.error_filter"
            }
          ],
          "doc": "Pushes an error scope onto the error scope stack.",
          "name": "push_error_scope"
        },
        {
          "callback": "callback.pop_error_scope",
          "doc": "Asynchronously pops an error scope from the error scope stack.",
          "name": "pop_error_scope"
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "device"
    },
    {
      "doc": "A top-level object representing a WebGPU instance.",
      "methods": [
        {
          "args": [
            {
              "doc": "The descriptor for the surface.",
              "name": "descriptor",
              "pointer": "immutable",
              "type": "struct.surface_descriptor"
            }
          ],
          "doc": "Creates a new surface.",
          "name": "create_surface",
          "returns": {
            "doc": "The created surface.",
            "passed_with_ownership": true,
            "type": "object.surface"
          }
        },
        {
          "args": [
            {
              "doc": "A structure to be filled with the supported features.",
              "name": "features",
              "pointer": "mutable",
              "type": "struct.supported_WGSL_language_features"
            }
          ],
          "doc": "Retrieves the list of WGSL language features supported by the instance.",
          "name": "get_WGSL_language_features"
        },
        {
          "args": [
            {
              "doc": "The feature to check for.",
              "name": "feature",
              "type": "enum.WGSL_language_feature_name"
            }
          ],
          "doc": "Checks if a specific WGSL language feature is supported.",
          "name": "has_WGSL_language_feature",
          "returns": {
            "doc": "`true` if the feature is supported, `false` otherwise.",
            "type": "bool"
          }
        },
        {
          "doc": "Processes pending asynchronous events and invokes their callbacks.",
          "name": "process_events"
        },
        {
          "args": [
            {
              "doc": "The options for the adapter request.",
              "name": "options",
              "optional": true,
              "pointer": "immutable",
              "type": "struct.request_adapter_options"
            }
          ],
          "callback": "callback.request_adapter",
          "doc": "Asynchronously requests a graphics adapter.",
          "name": "request_adapter"
        },
        {
          "args": [
            {
              "doc": "The number of futures to wait for.",
              "name": "future_count",
              "type": "usize"
            },
            {
              "doc": "An array of future wait info structures.",
              "name": "futures",
              "optional": true,
              "pointer": "mutable",
              "type": "struct.future_wait_info"
            },
            {
              "doc": "The timeout in nanoseconds.",
              "name": "timeout_NS",
              "type": "uint64"
            }
          ],
          "doc": "Waits for any of the specified futures to complete.",
          "name": "wait_any",
          "returns": {
            "doc": "The status of the wait operation.",
            "type": "enum.wait_status"
          }
        }
      ],
      "name": "instance"
    },
    {
      "doc": "The layout of a pipeline, defining the bind groups it uses.",
      "methods": [
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "pipeline_layout"
    },
    {
      "doc": "A set of queries for occlusion or timestamp measurements.",
      "methods": [
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        },
        {
          "doc": "Gets the type of queries in the set.",
          "name": "get_type",
          "returns": {
            "doc": "The query type.",
            "type": "enum.query_type"
          }
        },
        {
          "doc": "Gets the number of queries in the set.",
          "name": "get_count",
          "returns": {
            "doc": "The query count.",
            "type": "uint32"
          }
        },
        {
          "doc": "Destroys the query set and releases its resources.",
          "name": "destroy"
        }
      ],
      "name": "query_set"
    },
    {
      "doc": "A queue for submitting command buffers to the GPU.",
      "methods": [
        {
          "args": [
            {
              "doc": "An array of command buffers to submit.",
              "name": "commands",
              "pointer": "immutable",
              "type": "array\u003cobject.command_buffer\u003e"
            }
          ],
          "doc": "Submits a list of command buffers to be executed.",
          "name": "submit"
        },
        {
          "callback": "callback.queue_work_done",
          "doc": "Schedules a callback to be invoked when all previously submitted work is complete.",
          "name": "on_submitted_work_done"
        },
        {
          "args": [
            {
              "doc": "The destination buffer.",
              "name": "buffer",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the destination buffer.",
              "name": "buffer_offset",
              "type": "uint64"
            },
            {
              "doc": "A pointer to the data to write.",
              "name": "data",
              "pointer": "immutable",
              "type": "c_void"
            },
            {
              "doc": "The number of bytes to write.",
              "name": "size",
              "type": "usize"
            }
          ],
          "doc": "Writes data to a buffer from the CPU.",
          "name": "write_buffer"
        },
        {
          "args": [
            {
              "doc": "The destination texture information.",
              "name": "destination",
              "pointer": "immutable",
              "type": "struct.texel_copy_texture_info"
            },
            {
              "doc": "A pointer to the data to write.",
              "name": "data",
              "pointer": "immutable",
              "type": "c_void"
            },
            {
              "doc": "The total size of the data in bytes.",
              "name": "data_size",
              "type": "usize"
            },
            {
              "doc": "The layout of the data in the source buffer.",
              "name": "data_layout",
              "pointer": "immutable",
              "type": "struct.texel_copy_buffer_layout"
            },
            {
              "doc": "The size of the region to write.",
              "name": "write_size",
              "pointer": "immutable",
              "type": "struct.extent_3D"
            }
          ],
          "doc": "Writes data to a texture from the CPU.",
          "name": "write_texture"
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "queue"
    },
    {
      "doc": "A pre-recorded sequence of rendering commands.",
      "methods": [
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "render_bundle"
    },
    {
      "doc": "An object used to record commands for a render bundle.",
      "methods": [
        {
          "args": [
            {
              "doc": "The render pipeline to set.",
              "name": "pipeline",
              "type": "object.render_pipeline"
            }
          ],
          "doc": "Sets the current render pipeline.",
          "name": "set_pipeline"
        },
        {
          "args": [
            {
              "doc": "The index of the bind group.",
              "name": "group_index",
              "type": "uint32"
            },
            {
              "doc": "The bind group to set.",
              "name": "group",
              "optional": true,
              "type": "object.bind_group"
            },
            {
              "doc": "An array of dynamic offsets.",
              "name": "dynamic_offsets",
              "pointer": "immutable",
              "type": "array\u003cuint32\u003e"
            }
          ],
          "doc": "Sets a bind group for the pipeline.",
          "name": "set_bind_group"
        },
        {
          "args": [
            {
              "doc": "The number of vertices to draw.",
              "name": "vertex_count",
              "type": "uint32"
            },
            {
              "doc": "The number of instances to draw.",
              "name": "instance_count",
              "type": "uint32"
            },
            {
              "doc": "The index of the first vertex to draw.",
              "name": "first_vertex",
              "type": "uint32"
            },
            {
              "doc": "The index of the first instance to draw.",
              "name": "first_instance",
              "type": "uint32"
            }
          ],
          "doc": "Draws non-indexed primitives.",
          "name": "draw"
        },
        {
          "args": [
            {
              "doc": "The number of indices to draw.",
              "name": "index_count",
              "type": "uint32"
            },
            {
              "doc": "The number of instances to draw.",
              "name": "instance_count",
              "type": "uint32"
            },
            {
              "doc": "The index of the first index to draw.",
              "name": "first_index",
              "type": "uint32"
            },
            {
              "doc": "A value added to each index before reading from the vertex buffer.",
              "name": "base_vertex",
              "type": "int32"
            },
            {
              "doc": "The index of the first instance to draw.",
              "name": "first_instance",
              "type": "uint32"
            }
          ],
          "doc": "Draws indexed primitives.",
          "name": "draw_indexed"
        },
        {
          "args": [
            {
              "doc": "The buffer containing the draw parameters.",
              "name": "indirect_buffer",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the indirect buffer.",
              "name": "indirect_offset",
              "type": "uint64"
            }
          ],
          "doc": "Draws non-indexed primitives with parameters from a buffer.",
          "name": "draw_indirect"
        },
        {
          "args": [
            {
              "doc": "The buffer containing the draw parameters.",
              "name": "indirect_buffer",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the indirect buffer.",
              "name": "indirect_offset",
              "type": "uint64"
            }
          ],
          "doc": "Draws indexed primitives with parameters from a buffer.",
          "name": "draw_indexed_indirect"
        },
        {
          "args": [
            {
              "doc": "The label for the debug marker.",
              "name": "marker_label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Inserts a debug marker into the command stream.",
          "name": "insert_debug_marker"
        },
        {
          "doc": "Pops the current debug group.",
          "name": "pop_debug_group"
        },
        {
          "args": [
            {
              "doc": "The label for the debug group.",
              "name": "group_label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Pushes a new debug group.",
          "name": "push_debug_group"
        },
        {
          "args": [
            {
              "doc": "The vertex buffer slot.",
              "name": "slot",
              "type": "uint32"
            },
            {
              "doc": "The vertex buffer.",
              "name": "buffer",
              "optional": true,
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the vertex buffer.",
              "name": "offset",
              "type": "uint64"
            },
            {
              "doc": "The size of the vertex data to use.",
              "name": "size",
              "type": "uint64"
            }
          ],
          "doc": "Sets a vertex buffer for a specific slot.",
          "name": "set_vertex_buffer"
        },
        {
          "args": [
            {
              "doc": "The index buffer.",
              "name": "buffer",
              "type": "object.buffer"
            },
            {
              "doc": "The format of the indices.",
              "name": "format",
              "type": "enum.index_format"
            },
            {
              "doc": "The offset in the index buffer.",
              "name": "offset",
              "type": "uint64"
            },
            {
              "doc": "The size of the index data to use.",
              "name": "size",
              "type": "uint64"
            }
          ],
          "doc": "Sets the index buffer.",
          "name": "set_index_buffer"
        },
        {
          "args": [
            {
              "doc": "The descriptor for the render bundle.",
              "name": "descriptor",
              "optional": true,
              "pointer": "immutable",
              "type": "struct.render_bundle_descriptor"
            }
          ],
          "doc": "Finishes recording commands and creates a render bundle.",
          "name": "finish",
          "returns": {
            "doc": "The created render bundle.",
            "passed_with_ownership": true,
            "type": "object.render_bundle"
          }
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "render_bundle_encoder"
    },
    {
      "doc": "An object used to record commands for a render pass.",
      "methods": [
        {
          "args": [
            {
              "doc": "The render pipeline to set.",
              "name": "pipeline",
              "type": "object.render_pipeline"
            }
          ],
          "doc": "Sets the current render pipeline.",
          "name": "set_pipeline"
        },
        {
          "args": [
            {
              "doc": "The index of the bind group.",
              "name": "group_index",
              "type": "uint32"
            },
            {
              "doc": "The bind group to set.",
              "name": "group",
              "optional": true,
              "type": "object.bind_group"
            },
            {
              "doc": "An array of dynamic offsets.",
              "name": "dynamic_offsets",
              "pointer": "immutable",
              "type": "array\u003cuint32\u003e"
            }
          ],
          "doc": "Sets a bind group for the pipeline.",
          "name": "set_bind_group"
        },
        {
          "args": [
            {
              "doc": "The number of vertices to draw.",
              "name": "vertex_count",
              "type": "uint32"
            },
            {
              "doc": "The number of instances to draw.",
              "name": "instance_count",
              "type": "uint32"
            },
            {
              "doc": "The index of the first vertex to draw.",
              "name": "first_vertex",
              "type": "uint32"
            },
            {
              "doc": "The index of the first instance to draw.",
              "name": "first_instance",
              "type": "uint32"
            }
          ],
          "doc": "Draws non-indexed primitives.",
          "name": "draw"
        },
        {
          "args": [
            {
              "doc": "The number of indices to draw.",
              "name": "index_count",
              "type": "uint32"
            },
            {
              "doc": "The number of instances to draw.",
              "name": "instance_count",
              "type": "uint32"
            },
            {
              "doc": "The index of the first index to draw.",
              "name": "first_index",
              "type": "uint32"
            },
            {
              "doc": "A value added to each index before reading from the vertex buffer.",
              "name": "base_vertex",
              "type": "int32"
            },
            {
              "doc": "The index of the first instance to draw.",
              "name": "first_instance",
              "type": "uint32"
            }
          ],
          "doc": "Draws indexed primitives.",
          "name": "draw_indexed"
        },
        {
          "args": [
            {
              "doc": "The buffer containing the draw parameters.",
              "name": "indirect_buffer",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the indirect buffer.",
              "name": "indirect_offset",
              "type": "uint64"
            }
          ],
          "doc": "Draws non-indexed primitives with parameters from a buffer.",
          "name": "draw_indirect"
        },
        {
          "args": [
            {
              "doc": "The buffer containing the draw parameters.",
              "name": "indirect_buffer",
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the indirect buffer.",
              "name": "indirect_offset",
              "type": "uint64"
            }
          ],
          "doc": "Draws indexed primitives with parameters from a buffer.",
          "name": "draw_indexed_indirect"
        },
        {
          "args": [
            {
              "doc": "An array of render bundles to execute.",
              "name": "bundles",
              "pointer": "immutable",
              "type": "array\u003cobject.render_bundle\u003e"
            }
          ],
          "doc": "Executes a list of render bundles.",
          "name": "execute_bundles"
        },
        {
          "args": [
            {
              "doc": "The label for the debug marker.",
              "name": "marker_label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Inserts a debug marker into the command stream.",
          "name": "insert_debug_marker"
        },
        {
          "doc": "Pops the current debug group.",
          "name": "pop_debug_group"
        },
        {
          "args": [
            {
              "doc": "The label for the debug group.",
              "name": "group_label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Pushes a new debug group.",
          "name": "push_debug_group"
        },
        {
          "args": [
            {
              "doc": "The stencil reference value.",
              "name": "reference",
              "type": "uint32"
            }
          ],
          "doc": "Sets the stencil reference value.",
          "name": "set_stencil_reference"
        },
        {
          "args": [
            {
              "doc": "The RGBA blend constant.",
              "name": "color",
              "pointer": "immutable",
              "type": "struct.color"
            }
          ],
          "doc": "Sets the blend constant color.",
          "name": "set_blend_constant"
        },
        {
          "args": [
            {
              "doc": "The x-coordinate of the viewport.",
              "name": "x",
              "type": "float32"
            },
            {
              "doc": "The y-coordinate of the viewport.",
              "name": "y",
              "type": "float32"
            },
            {
              "doc": "The width of the viewport.",
              "name": "width",
              "type": "float32"
            },
            {
              "doc": "The height of the viewport.",
              "name": "height",
              "type": "float32"
            },
            {
              "doc": "The minimum depth of the viewport.",
              "name": "min_depth",
              "type": "float32"
            },
            {
              "doc": "The maximum depth of the viewport.",
              "name": "max_depth",
              "type": "float32"
            }
          ],
          "doc": "Sets the viewport rectangle.",
          "name": "set_viewport"
        },
        {
          "args": [
            {
              "doc": "The x-coordinate of the scissor rectangle.",
              "name": "x",
              "type": "uint32"
            },
            {
              "doc": "The y-coordinate of the scissor rectangle.",
              "name": "y",
              "type": "uint32"
            },
            {
              "doc": "The width of the scissor rectangle.",
              "name": "width",
              "type": "uint32"
            },
            {
              "doc": "The height of the scissor rectangle.",
              "name": "height",
              "type": "uint32"
            }
          ],
          "doc": "Sets the scissor rectangle.",
          "name": "set_scissor_rect"
        },
        {
          "args": [
            {
              "doc": "The vertex buffer slot.",
              "name": "slot",
              "type": "uint32"
            },
            {
              "doc": "The vertex buffer.",
              "name": "buffer",
              "optional": true,
              "type": "object.buffer"
            },
            {
              "doc": "The offset in the vertex buffer.",
              "name": "offset",
              "type": "uint64"
            },
            {
              "doc": "The size of the vertex data to use.",
              "name": "size",
              "type": "uint64"
            }
          ],
          "doc": "Sets a vertex buffer for a specific slot.",
          "name": "set_vertex_buffer"
        },
        {
          "args": [
            {
              "doc": "The index buffer.",
              "name": "buffer",
              "type": "object.buffer"
            },
            {
              "doc": "The format of the indices.",
              "name": "format",
              "type": "enum.index_format"
            },
            {
              "doc": "The offset in the index buffer.",
              "name": "offset",
              "type": "uint64"
            },
            {
              "doc": "The size of the index data to use.",
              "name": "size",
              "type": "uint64"
            }
          ],
          "doc": "Sets the index buffer.",
          "name": "set_index_buffer"
        },
        {
          "args": [
            {
              "doc": "The index of the query in the query set.",
              "name": "query_index",
              "type": "uint32"
            }
          ],
          "doc": "Begins an occlusion query.",
          "name": "begin_occlusion_query"
        },
        {
          "doc": "Ends an occlusion query.",
          "name": "end_occlusion_query"
        },
        {
          "doc": "Ends the render pass.",
          "name": "end"
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "render_pass_encoder"
    },
    {
      "doc": "A pipeline for rendering operations.",
      "methods": [
        {
          "args": [
            {
              "doc": "The index of the bind group.",
              "name": "group_index",
              "type": "uint32"
            }
          ],
          "doc": "Gets the layout of a bind group for this pipeline.",
          "name": "get_bind_group_layout",
          "returns": {
            "doc": "The bind group layout.",
            "passed_with_ownership": true,
            "type": "object.bind_group_layout"
          }
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "render_pipeline"
    },
    {
      "doc": "An object that controls how textures are sampled in a shader.",
      "methods": [
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "sampler"
    },
    {
      "doc": "A compiled shader module.",
      "methods": [
        {
          "callback": "callback.compilation_info",
          "doc": "Asynchronously retrieves compilation information for the shader module.",
          "name": "get_compilation_info"
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "shader_module"
    },
    {
      "doc": "An object representing a platform-specific surface for rendering.",
      "methods": [
        {
          "args": [
            {
              "doc": "The new configuration for the surface.",
              "name": "config",
              "pointer": "immutable",
              "type": "struct.surface_configuration"
            }
          ],
          "doc": "Configures the surface for rendering.",
          "name": "configure"
        },
        {
          "args": [
            {
              "doc": "The adapter to query capabilities for.",
              "name": "adapter",
              "type": "object.adapter"
            },
            {
              "doc": "A structure to be filled with the surface capabilities.",
              "name": "capabilities",
              "passed_with_ownership": true,
              "pointer": "mutable",
              "type": "struct.surface_capabilities"
            }
          ],
          "doc": "Retrieves the capabilities of the surface for a given adapter.",
          "name": "get_capabilities",
          "returns": {
            "doc": "The status of the operation.",
            "type": "enum.status"
          }
        },
        {
          "args": [
            {
              "doc": "A structure to be filled with the current texture and status.",
              "name": "surface_texture",
              "pointer": "mutable",
              "type": "struct.surface_texture"
            }
          ],
          "doc": "Gets the texture for the current frame to be rendered to.",
          "name": "get_current_texture"
        },
        {
          "doc": "Presents the current texture to the user.",
          "name": "present",
          "returns": {
            "doc": "The status of the operation.",
            "type": "enum.status"
          }
        },
        {
          "doc": "Removes the configuration for the surface.",
          "name": "unconfigure"
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "surface"
    },
    {
      "doc": "A GPU texture object.",
      "methods": [
        {
          "args": [
            {
              "doc": "The descriptor for the texture view.",
              "name": "descriptor",
              "optional": true,
              "pointer": "immutable",
              "type": "struct.texture_view_descriptor"
            }
          ],
          "doc": "Creates a new view of the texture.",
          "name": "create_view",
          "returns": {
            "doc": "The created texture view.",
            "passed_with_ownership": true,
            "type": "object.texture_view"
          }
        },
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        },
        {
          "doc": "Gets the width of the texture.",
          "name": "get_width",
          "returns": {
            "doc": "The texture width.",
            "type": "uint32"
          }
        },
        {
          "doc": "Gets the height of the texture.",
          "name": "get_height",
          "returns": {
            "doc": "The texture height.",
            "type": "uint32"
          }
        },
        {
          "doc": "Gets the depth or number of array layers of the texture.",
          "name": "get_depth_or_array_layers",
          "returns": {
            "doc": "The texture depth or layer count.",
            "type": "uint32"
          }
        },
        {
          "doc": "Gets the number of mipmap levels of the texture.",
          "name": "get_mip_level_count",
          "returns": {
            "doc": "The mipmap level count.",
            "type": "uint32"
          }
        },
        {
          "doc": "Gets the sample count of the texture.",
          "name": "get_sample_count",
          "returns": {
            "doc": "The sample count.",
            "type": "uint32"
          }
        },
        {
          "doc": "Gets the dimension of the texture.",
          "name": "get_dimension",
          "returns": {
            "doc": "The texture dimension.",
            "type": "enum.texture_dimension"
          }
        },
        {
          "doc": "Gets the format of the texture.",
          "name": "get_format",
          "returns": {
            "doc": "The texture format.",
            "type": "enum.texture_format"
          }
        },
        {
          "doc": "Gets the allowed usages of the texture.",
          "name": "get_usage",
          "returns": {
            "doc": "The texture usage flags.",
            "type": "bitflag.texture_usage"
          }
        },
        {
          "doc": "Destroys the texture and releases its resources.",
          "name": "destroy"
        }
      ],
      "name": "texture"
    },
    {
      "doc": "A view into a texture, defining a specific sub-resource or reinterpretation of the texture's data.",
      "methods": [
        {
          "args": [
            {
              "doc": "The label string.",
              "name": "label",
              "type": "string_with_default_empty"
            }
          ],
          "doc": "Sets a human-readable label for debugging.",
          "name": "set_label"
        }
      ],
      "name": "texture_view"
    }
  ],
  "structs": [
    {
      "doc": "Provides detailed information about a graphics adapter.",
      "free_members": true,
      "members": [
        {
          "doc": "The name of the adapter vendor.",
          "name": "vendor",
          "type": "out_string"
        },
        {
          "doc": "The name of the adapter architecture.",
          "name": "architecture",
          "type": "out_string"
        },
        {
          "doc": "A vendor-specific device identifier.",
          "name": "device",
          "type": "out_string"
        },
        {
          "doc": "A human-readable description of the adapter.",
          "name": "description",
          "type": "out_string"
        },
        {
          "doc": "The backend graphics API in use.",
          "name": "backend_type",
          "type": "enum.backend_type"
        },
        {
          "doc": "The type of the adapter (e.g., discrete, integrated).",
          "name": "adapter_type",
          "type": "enum.adapter_type"
        },
        {
          "doc": "The PCI vendor ID of the adapter.",
          "name": "vendor_ID",
          "type": "uint32"
        },
        {
          "doc": "The PCI device ID of the adapter.",
          "name": "device_ID",
          "type": "uint32"
        },
        {
          "doc": "The minimum subgroup size supported by the adapter.",
          "name": "subgroup_min_size",
          "type": "uint32"
        },
        {
          "doc": "The maximum subgroup size supported by the adapter.",
          "name": "subgroup_max_size",
          "type": "uint32"
        }
      ],
      "name": "adapter_info",
      "type": "extensible"
    },
    {
      "doc": "Describes a bind group, which is a collection of resources to be bound to a pipeline.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "The layout of the bind group.",
          "name": "layout",
          "type": "object.bind_group_layout"
        },
        {
          "doc": "An array of entries describing the resources in the bind group.",
          "name": "entries",
          "pointer": "immutable",
          "type": "array\u003cstruct.bind_group_entry\u003e"
        }
      ],
      "name": "bind_group_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a single resource binding within a bind group.",
      "members": [
        {
          "doc": "The binding index corresponding to a shader resource.",
          "name": "binding",
          "type": "uint32"
        },
        {
          "doc": "The buffer to bind. Must be `NULL` if `sampler` or `textureView` is set.",
          "name": "buffer",
          "optional": true,
          "type": "object.buffer"
        },
        {
          "doc": "The offset in bytes from the beginning of the buffer.",
          "name": "offset",
          "type": "uint64"
        },
        {
          "default": "constant.whole_size",
          "doc": "The size in bytes of the buffer binding.",
          "name": "size",
          "type": "uint64"
        },
        {
          "doc": "The sampler to bind. Must be `NULL` if `buffer` or `textureView` is set.",
          "name": "sampler",
          "optional": true,
          "type": "object.sampler"
        },
        {
          "doc": "The texture view to bind. Must be `NULL` if `buffer` or `sampler` is set.",
          "name": "texture_view",
          "optional": true,
          "type": "object.texture_view"
        }
      ],
      "name": "bind_group_entry",
      "type": "extensible"
    },
    {
      "doc": "Describes the layout of a bind group, specifying the types of resources it contains.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "An array of entries describing the layout of each binding.",
          "name": "entries",
          "pointer": "immutable",
          "type": "array\u003cstruct.bind_group_layout_entry\u003e"
        }
      ],
      "name": "bind_group_layout_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a single binding within a bind group layout.",
      "members": [
        {
          "doc": "The binding index.",
          "name": "binding",
          "type": "uint32"
        },
        {
          "default": "none",
          "doc": "The shader stages in which the binding is visible.",
          "name": "visibility",
          "type": "bitflag.shader_stage"
        },
        {
          "doc": "The size of the binding array, if non-zero.",
          "name": "binding_array_size",
          "type": "uint32"
        },
        {
          "default": "zero",
          "doc": "The buffer binding layout.",
          "name": "buffer",
          "type": "struct.buffer_binding_layout"
        },
        {
          "default": "zero",
          "doc": "The sampler binding layout.",
          "name": "sampler",
          "type": "struct.sampler_binding_layout"
        },
        {
          "default": "zero",
          "doc": "The texture binding layout.",
          "name": "texture",
          "type": "struct.texture_binding_layout"
        },
        {
          "default": "zero",
          "doc": "The storage texture binding layout.",
          "name": "storage_texture",
          "type": "struct.storage_texture_binding_layout"
        }
      ],
      "name": "bind_group_layout_entry",
      "type": "extensible"
    },
    {
      "doc": "Defines the blending behavior for a single color component (color or alpha).",
      "members": [
        {
          "doc": "The blend operation to perform. Defaults to @ref WGPUBlendOperation_Add if `undefined`.",
          "name": "operation",
          "type": "enum.blend_operation"
        },
        {
          "doc": "The blend factor for the source component. Defaults to @ref WGPUBlendFactor_One if `undefined`.",
          "name": "src_factor",
          "type": "enum.blend_factor"
        },
        {
          "doc": "The blend factor for the destination component. Defaults to @ref WGPUBlendFactor_Zero if `undefined`.",
          "name": "dst_factor",
          "type": "enum.blend_factor"
        }
      ],
      "name": "blend_component",
      "type": "standalone"
    },
    {
      "doc": "Defines the blending configuration for a color attachment.",
      "members": [
        {
          "doc": "The blend component for the RGB channels.",
          "name": "color",
          "type": "struct.blend_component"
        },
        {
          "doc": "The blend component for the alpha channel.",
          "name": "alpha",
          "type": "struct.blend_component"
        }
      ],
      "name": "blend_state",
      "type": "standalone"
    },
    {
      "doc": "Describes the layout of a buffer binding.",
      "members": [
        {
          "doc": "The type of the buffer binding. Defaults to @ref WGPUBufferBindingType_Uniform if `undefined`.",
          "name": "type",
          "type": "enum.buffer_binding_type"
        },
        {
          "default": false,
          "doc": "Specifies whether the buffer has a dynamic offset.",
          "name": "has_dynamic_offset",
          "type": "bool"
        },
        {
          "default": 0,
          "doc": "The minimum required size of the buffer binding.",
          "name": "min_binding_size",
          "type": "uint64"
        }
      ],
      "name": "buffer_binding_layout",
      "type": "extensible"
    },
    {
      "doc": "Describes a buffer to be created.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "default": "none",
          "doc": "The allowed usages for the buffer.",
          "name": "usage",
          "type": "bitflag.buffer_usage"
        },
        {
          "doc": "The size of the buffer in bytes.",
          "name": "size",
          "type": "uint64"
        },
        {
          "default": false,
          "doc": "If `true`, the buffer is mapped for writing upon creation.",
          "name": "mapped_at_creation",
          "type": "bool"
        }
      ],
      "name": "buffer_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Represents an RGBA color value.",
      "members": [
        {
          "doc": "The red component.",
          "name": "r",
          "type": "float64_supertype"
        },
        {
          "doc": "The green component.",
          "name": "g",
          "type": "float64_supertype"
        },
        {
          "doc": "The blue component.",
          "name": "b",
          "type": "float64_supertype"
        },
        {
          "doc": "The alpha component.",
          "name": "a",
          "type": "float64_supertype"
        }
      ],
      "name": "color",
      "type": "standalone"
    },
    {
      "doc": "Describes the state of a single color target in a render pipeline.",
      "members": [
        {
          "doc": "The texture format of the color target.",
          "name": "format",
          "type": "enum.texture_format"
        },
        {
          "doc": "The blending state for this target.",
          "name": "blend",
          "optional": true,
          "pointer": "immutable",
          "type": "struct.blend_state"
        },
        {
          "default": "all",
          "doc": "A bitmask controlling which color channels are written.",
          "name": "write_mask",
          "type": "bitflag.color_write_mask"
        }
      ],
      "name": "color_target_state",
      "type": "extensible"
    },
    {
      "doc": "Describes a command buffer.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        }
      ],
      "name": "command_buffer_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a command encoder.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        }
      ],
      "name": "command_encoder_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Contains information about a shader compilation, including messages.",
      "members": [
        {
          "doc": "An array of compilation messages.",
          "name": "messages",
          "pointer": "immutable",
          "type": "array\u003cstruct.compilation_message\u003e"
        }
      ],
      "name": "compilation_info",
      "type": "extensible_callback_arg"
    },
    {
      "doc": "Describes a single message generated during shader compilation.",
      "members": [
        {
          "doc": "The compilation message string.",
          "name": "message",
          "type": "out_string"
        },
        {
          "doc": "The severity of the message (error, warning, or info).",
          "name": "type",
          "type": "enum.compilation_message_type"
        },
        {
          "doc": "The line number where the message occurred.",
          "name": "line_num",
          "type": "uint64"
        },
        {
          "doc": "The position within the line where the message occurred.",
          "name": "line_pos",
          "type": "uint64"
        },
        {
          "doc": "The byte offset from the beginning of the shader source.",
          "name": "offset",
          "type": "uint64"
        },
        {
          "doc": "The length in bytes of the source code related to the message.",
          "name": "length",
          "type": "uint64"
        }
      ],
      "name": "compilation_message",
      "type": "extensible_callback_arg"
    },
    {
      "doc": "Describes a compute pass.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "The timestamp queries to write at the beginning and end of the pass.",
          "name": "timestamp_writes",
          "optional": true,
          "pointer": "immutable",
          "type": "struct.pass_timestamp_writes"
        }
      ],
      "name": "compute_pass_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a compute pipeline.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "The pipeline layout. If `NULL`, a default layout is inferred.",
          "name": "layout",
          "optional": true,
          "type": "object.pipeline_layout"
        },
        {
          "doc": "The compute shader stage configuration.",
          "name": "compute",
          "type": "struct.compute_state"
        }
      ],
      "name": "compute_pipeline_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes the compute shader stage of a pipeline.",
      "members": [
        {
          "doc": "The shader module containing the compute shader.",
          "name": "module",
          "type": "object.shader_module"
        },
        {
          "doc": "The name of the entry point function in the shader module.",
          "name": "entry_point",
          "type": "nullable_string"
        },
        {
          "doc": "An array of pipeline-overridable constants.",
          "name": "constants",
          "pointer": "immutable",
          "type": "array\u003cstruct.constant_entry\u003e"
        }
      ],
      "name": "compute_state",
      "type": "extensible"
    },
    {
      "doc": "Defines a key-value pair for a pipeline-overridable constant.",
      "members": [
        {
          "doc": "The name of the constant.",
          "name": "key",
          "type": "string_with_default_empty"
        },
        {
          "doc": "The value to override the constant with.",
          "name": "value",
          "type": "float64_supertype"
        }
      ],
      "name": "constant_entry",
      "type": "extensible"
    },
    {
      "doc": "Describes the depth and stencil state for a render pipeline.",
      "members": [
        {
          "doc": "The texture format of the depth-stencil attachment.",
          "name": "format",
          "type": "enum.texture_format"
        },
        {
          "doc": "Enables or disables writing to the depth buffer.",
          "name": "depth_write_enabled",
          "type": "enum.optional_bool"
        },
        {
          "doc": "The comparison function for the depth test.",
          "name": "depth_compare",
          "type": "enum.compare_function"
        },
        {
          "doc": "The stencil state for front-facing primitives.",
          "name": "stencil_front",
          "type": "struct.stencil_face_state"
        },
        {
          "doc": "The stencil state for back-facing primitives.",
          "name": "stencil_back",
          "type": "struct.stencil_face_state"
        },
        {
          "default": "0xFFFFFFFF",
          "doc": "The bitmask for stencil read operations.",
          "name": "stencil_read_mask",
          "type": "uint32"
        },
        {
          "default": "0xFFFFFFFF",
          "doc": "The bitmask for stencil write operations.",
          "name": "stencil_write_mask",
          "type": "uint32"
        },
        {
          "default": 0,
          "doc": "A constant depth bias added to each fragment.",
          "name": "depth_bias",
          "type": "int32"
        },
        {
          "default": 0,
          "doc": "A slope-scaled depth bias.",
          "name": "depth_bias_slope_scale",
          "type": "float32"
        },
        {
          "default": 0,
          "doc": "The maximum value for the depth bias.",
          "name": "depth_bias_clamp",
          "type": "float32"
        }
      ],
      "name": "depth_stencil_state",
      "type": "extensible"
    },
    {
      "doc": "Describes a device to be created.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "An array of features required by the device.",
          "name": "required_features",
          "pointer": "immutable",
          "type": "array\u003cenum.feature_name\u003e"
        },
        {
          "doc": "The limits required by the device.",
          "name": "required_limits",
          "optional": true,
          "pointer": "immutable",
          "type": "struct.limits"
        },
        {
          "doc": "The descriptor for the default queue of the device.",
          "name": "default_queue",
          "type": "struct.queue_descriptor"
        },
        {
          "doc": "The callback for device loss events.",
          "name": "device_lost_callback_info",
          "type": "callback.device_lost"
        },
        {
          "doc": "The callback for uncaptured errors.",
          "name": "uncaptured_error_callback_info",
          "type": "callback.uncaptured_error"
        }
      ],
      "name": "device_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Defines a three-dimensional extent (width, height, depth/layers).",
      "members": [
        {
          "doc": "The width of the extent.",
          "name": "width",
          "type": "uint32"
        },
        {
          "default": 1,
          "doc": "The height of the extent.",
          "name": "height",
          "type": "uint32"
        },
        {
          "default": 1,
          "doc": "The depth or number of array layers of the extent.",
          "name": "depth_or_array_layers",
          "type": "uint32"
        }
      ],
      "name": "extent_3D",
      "type": "standalone"
    },
    {
      "doc": "Describes the fragment shader stage of a render pipeline.",
      "members": [
        {
          "doc": "The shader module containing the fragment shader.",
          "name": "module",
          "type": "object.shader_module"
        },
        {
          "doc": "The name of the entry point function in the shader module.",
          "name": "entry_point",
          "type": "nullable_string"
        },
        {
          "doc": "An array of pipeline-overridable constants.",
          "name": "constants",
          "pointer": "immutable",
          "type": "array\u003cstruct.constant_entry\u003e"
        },
        {
          "doc": "An array of color target states.",
          "name": "targets",
          "pointer": "immutable",
          "type": "array\u003cstruct.color_target_state\u003e"
        }
      ],
      "name": "fragment_state",
      "type": "extensible"
    },
    {
      "doc": "An opaque handle representing the result of an asynchronous operation.",
      "members": [
        {
          "doc": "The unique identifier of the future.",
          "name": "id",
          "type": "uint64"
        }
      ],
      "name": "future",
      "type": "standalone"
    },
    {
      "doc": "A structure for waiting on a future and receiving its completion status.",
      "members": [
        {
          "doc": "The future to wait on.",
          "name": "future",
          "type": "struct.future"
        },
        {
          "doc": "A boolean flag indicating if the future has completed.",
          "name": "completed",
          "type": "bool"
        }
      ],
      "name": "future_wait_info",
      "type": "standalone"
    },
    {
      "doc": "Describes an instance to be created.",
      "members": [
        {
          "doc": "An array of features required by the instance.",
          "name": "required_features",
          "pointer": "immutable",
          "type": "array\u003cenum.instance_feature_name\u003e"
        },
        {
          "doc": "The limits required by the instance.",
          "name": "required_limits",
          "optional": true,
          "pointer": "immutable",
          "type": "struct.instance_limits"
        }
      ],
      "name": "instance_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Defines limits for an instance.",
      "members": [
        {
          "doc": "The maximum number of futures supported in a timed call to @ref wgpuInstanceWaitAny.",
          "name": "timed_wait_any_max_count",
          "type": "usize"
        }
      ],
      "name": "instance_limits",
      "type": "extensible"
    },
    {
      "doc": "Defines the resource limits for a device.",
      "members": [
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum width of a 1D texture.",
          "name": "max_texture_dimension_1D",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum width and height of a 2D texture.",
          "name": "max_texture_dimension_2D",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum width, height, and depth of a 3D texture.",
          "name": "max_texture_dimension_3D",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of array layers in a texture.",
          "name": "max_texture_array_layers",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of bind groups per pipeline layout.",
          "name": "max_bind_groups",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of bind groups and vertex buffers used simultaneously.",
          "name": "max_bind_groups_plus_vertex_buffers",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of bindings per bind group.",
          "name": "max_bindings_per_bind_group",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of dynamic uniform buffers per pipeline layout.",
          "name": "max_dynamic_uniform_buffers_per_pipeline_layout",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of dynamic storage buffers per pipeline layout.",
          "name": "max_dynamic_storage_buffers_per_pipeline_layout",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of sampled textures per shader stage.",
          "name": "max_sampled_textures_per_shader_stage",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of samplers per shader stage.",
          "name": "max_samplers_per_shader_stage",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of storage buffers per shader stage.",
          "name": "max_storage_buffers_per_shader_stage",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of storage textures per shader stage.",
          "name": "max_storage_textures_per_shader_stage",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of uniform buffers per shader stage.",
          "name": "max_uniform_buffers_per_shader_stage",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u64_undefined",
          "doc": "The maximum size of a uniform buffer binding.",
          "name": "max_uniform_buffer_binding_size",
          "type": "uint64"
        },
        {
          "default": "constant.limit_u64_undefined",
          "doc": "The maximum size of a storage buffer binding.",
          "name": "max_storage_buffer_binding_size",
          "type": "uint64"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The minimum required alignment for uniform buffer offsets.",
          "name": "min_uniform_buffer_offset_alignment",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The minimum required alignment for storage buffer offsets.",
          "name": "min_storage_buffer_offset_alignment",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of vertex buffers.",
          "name": "max_vertex_buffers",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u64_undefined",
          "doc": "The maximum size of a buffer.",
          "name": "max_buffer_size",
          "type": "uint64"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of vertex attributes.",
          "name": "max_vertex_attributes",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum stride for a vertex buffer.",
          "name": "max_vertex_buffer_array_stride",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of inter-stage shader variables.",
          "name": "max_inter_stage_shader_variables",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of color attachments.",
          "name": "max_color_attachments",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of bytes per sample for color attachments.",
          "name": "max_color_attachment_bytes_per_sample",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum storage size per compute workgroup.",
          "name": "max_compute_workgroup_storage_size",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of invocations per compute workgroup.",
          "name": "max_compute_invocations_per_workgroup",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum X dimension of a compute workgroup.",
          "name": "max_compute_workgroup_size_x",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum Y dimension of a compute workgroup.",
          "name": "max_compute_workgroup_size_y",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum Z dimension of a compute workgroup.",
          "name": "max_compute_workgroup_size_z",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum number of compute workgroups per dimension.",
          "name": "max_compute_workgroups_per_dimension",
          "type": "uint32"
        },
        {
          "default": "constant.limit_u32_undefined",
          "doc": "The maximum size for immediate data.",
          "name": "max_immediate_size",
          "type": "uint32"
        }
      ],
      "name": "limits",
      "type": "extensible"
    },
    {
      "doc": "Describes the multisampling state for a render pipeline.",
      "members": [
        {
          "default": 1,
          "doc": "The number of samples per pixel.",
          "name": "count",
          "type": "uint32"
        },
        {
          "default": "0xFFFFFFFF",
          "doc": "A bitmask controlling which samples are written.",
          "name": "mask",
          "type": "uint32"
        },
        {
          "default": false,
          "doc": "Enables or disables alpha-to-coverage.",
          "name": "alpha_to_coverage_enabled",
          "type": "bool"
        }
      ],
      "name": "multisample_state",
      "type": "extensible"
    },
    {
      "doc": "Defines a three-dimensional origin point (x, y, z).",
      "members": [
        {
          "default": 0,
          "doc": "The x-coordinate of the origin.",
          "name": "x",
          "type": "uint32"
        },
        {
          "default": 0,
          "doc": "The y-coordinate of the origin.",
          "name": "y",
          "type": "uint32"
        },
        {
          "default": 0,
          "doc": "The z-coordinate of the origin.",
          "name": "z",
          "type": "uint32"
        }
      ],
      "name": "origin_3D",
      "type": "standalone"
    },
    {
      "doc": "Describes the timestamp queries to be written during a pass.",
      "members": [
        {
          "doc": "The query set to write timestamps to.",
          "name": "query_set",
          "type": "object.query_set"
        },
        {
          "default": "constant.query_set_index_undefined",
          "doc": "The index in the query set to write the beginning timestamp.",
          "name": "beginning_of_pass_write_index",
          "type": "uint32"
        },
        {
          "default": "constant.query_set_index_undefined",
          "doc": "The index in the query set to write the end timestamp.",
          "name": "end_of_pass_write_index",
          "type": "uint32"
        }
      ],
      "name": "pass_timestamp_writes",
      "type": "extensible"
    },
    {
      "doc": "Describes a pipeline layout.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "An array of bind group layouts.",
          "name": "bind_group_layouts",
          "pointer": "immutable",
          "type": "array\u003cobject.bind_group_layout\u003e"
        },
        {
          "default": 0,
          "doc": "The size of immediate data for the pipeline layout.",
          "name": "immediate_size",
          "type": "uint32"
        }
      ],
      "name": "pipeline_layout_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes the primitive assembly and rasterization state for a render pipeline.",
      "members": [
        {
          "doc": "The primitive topology. Defaults to @ref WGPUPrimitiveTopology_TriangleList if `undefined`.",
          "name": "topology",
          "type": "enum.primitive_topology"
        },
        {
          "doc": "The index format for strip topologies.",
          "name": "strip_index_format",
          "type": "enum.index_format"
        },
        {
          "doc": "The winding order for front-facing primitives. Defaults to @ref WGPUFrontFace_CCW if `undefined`.",
          "name": "front_face",
          "type": "enum.front_face"
        },
        {
          "doc": "The face culling mode. Defaults to @ref WGPUCullMode_None if `undefined`.",
          "name": "cull_mode",
          "type": "enum.cull_mode"
        },
        {
          "default": false,
          "doc": "Enables or disables depth clipping. Requires @ref WGPUFeatureName_DepthClipControl.",
          "name": "unclipped_depth",
          "type": "bool"
        }
      ],
      "name": "primitive_state",
      "type": "extensible"
    },
    {
      "doc": "Describes a query set.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "The type of queries in the set.",
          "name": "type",
          "type": "enum.query_type"
        },
        {
          "doc": "The number of queries in the set.",
          "name": "count",
          "type": "uint32"
        }
      ],
      "name": "query_set_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a queue.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        }
      ],
      "name": "queue_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a render bundle.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        }
      ],
      "name": "render_bundle_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a render bundle encoder.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "An array of color attachment formats.",
          "name": "color_formats",
          "pointer": "immutable",
          "type": "array\u003cenum.texture_format\u003e"
        },
        {
          "doc": "The format of the depth-stencil attachment.",
          "name": "depth_stencil_format",
          "type": "enum.texture_format"
        },
        {
          "default": 1,
          "doc": "The sample count of the render targets.",
          "name": "sample_count",
          "type": "uint32"
        },
        {
          "default": false,
          "doc": "Specifies if the depth aspect is read-only.",
          "name": "depth_read_only",
          "type": "bool"
        },
        {
          "default": false,
          "doc": "Specifies if the stencil aspect is read-only.",
          "name": "stencil_read_only",
          "type": "bool"
        }
      ],
      "name": "render_bundle_encoder_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a color attachment for a render pass.",
      "members": [
        {
          "doc": "The texture view for the color attachment.",
          "name": "view",
          "optional": true,
          "type": "object.texture_view"
        },
        {
          "default": "constant.depth_slice_undefined",
          "doc": "The depth slice to use for 3D textures.",
          "name": "depth_slice",
          "type": "uint32"
        },
        {
          "doc": "The texture view to resolve multisampled content to.",
          "name": "resolve_target",
          "optional": true,
          "type": "object.texture_view"
        },
        {
          "doc": "The operation to perform on the attachment at the beginning of the pass.",
          "name": "load_op",
          "type": "enum.load_op"
        },
        {
          "doc": "The operation to perform on the attachment at the end of the pass.",
          "name": "store_op",
          "type": "enum.store_op"
        },
        {
          "doc": "The color to clear the attachment to if `loadOp` is @ref WGPULoadOp_Clear.",
          "name": "clear_value",
          "type": "struct.color"
        }
      ],
      "name": "render_pass_color_attachment",
      "type": "extensible"
    },
    {
      "doc": "Describes a depth-stencil attachment for a render pass.",
      "members": [
        {
          "doc": "The texture view for the depth-stencil attachment.",
          "name": "view",
          "type": "object.texture_view"
        },
        {
          "doc": "The load operation for the depth aspect.",
          "name": "depth_load_op",
          "type": "enum.load_op"
        },
        {
          "doc": "The store operation for the depth aspect.",
          "name": "depth_store_op",
          "type": "enum.store_op"
        },
        {
          "default": "constant.depth_clear_value_undefined",
          "doc": "The value to clear the depth aspect to.",
          "name": "depth_clear_value",
          "type": "nullable_float32"
        },
        {
          "default": false,
          "doc": "Specifies if the depth aspect is read-only.",
          "name": "depth_read_only",
          "type": "bool"
        },
        {
          "doc": "The load operation for the stencil aspect.",
          "name": "stencil_load_op",
          "type": "enum.load_op"
        },
        {
          "doc": "The store operation for the stencil aspect.",
          "name": "stencil_store_op",
          "type": "enum.store_op"
        },
        {
          "doc": "The value to clear the stencil aspect to.",
          "name": "stencil_clear_value",
          "type": "uint32"
        },
        {
          "default": false,
          "doc": "Specifies if the stencil aspect is read-only.",
          "name": "stencil_read_only",
          "type": "bool"
        }
      ],
      "name": "render_pass_depth_stencil_attachment",
      "type": "extensible"
    },
    {
      "doc": "Describes a render pass.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "An array of color attachments.",
          "name": "color_attachments",
          "pointer": "immutable",
          "type": "array\u003cstruct.render_pass_color_attachment\u003e"
        },
        {
          "doc": "The depth-stencil attachment.",
          "name": "depth_stencil_attachment",
          "optional": true,
          "pointer": "immutable",
          "type": "struct.render_pass_depth_stencil_attachment"
        },
        {
          "doc": "The query set for occlusion queries.",
          "name": "occlusion_query_set",
          "optional": true,
          "type": "object.query_set"
        },
        {
          "doc": "The timestamp queries to write at the beginning and end of the pass.",
          "name": "timestamp_writes",
          "optional": true,
          "pointer": "immutable",
          "type": "struct.pass_timestamp_writes"
        }
      ],
      "name": "render_pass_descriptor",
      "type": "extensible"
    },
    {
      "doc": "An extension for specifying the maximum draw count in a render pass.",
      "extends": ["render_pass_descriptor"],
      "members": [
        {
          "default": 50000000,
          "doc": "The maximum number of draw calls allowed in the pass.",
          "name": "max_draw_count",
          "type": "uint64"
        }
      ],
      "name": "render_pass_max_draw_count",
      "type": "extension"
    },
    {
      "doc": "Describes a render pipeline.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "The pipeline layout. If `NULL`, a default layout is inferred.",
          "name": "layout",
          "optional": true,
          "type": "object.pipeline_layout"
        },
        {
          "doc": "The vertex shader stage configuration.",
          "name": "vertex",
          "type": "struct.vertex_state"
        },
        {
          "doc": "The primitive assembly and rasterization state.",
          "name": "primitive",
          "type": "struct.primitive_state"
        },
        {
          "doc": "The depth-stencil state.",
          "name": "depth_stencil",
          "optional": true,
          "pointer": "immutable",
          "type": "struct.depth_stencil_state"
        },
        {
          "doc": "The multisampling state.",
          "name": "multisample",
          "type": "struct.multisample_state"
        },
        {
          "doc": "The fragment shader stage configuration.",
          "name": "fragment",
          "optional": true,
          "pointer": "immutable",
          "type": "struct.fragment_state"
        }
      ],
      "name": "render_pipeline_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Options for requesting a graphics adapter.",
      "members": [
        {
          "doc": "The minimum feature level required for the adapter.",
          "name": "feature_level",
          "type": "enum.feature_level"
        },
        {
          "doc": "The power preference for the adapter.",
          "name": "power_preference",
          "type": "enum.power_preference"
        },
        {
          "default": false,
          "doc": "If `true`, requests a fallback software adapter.",
          "name": "force_fallback_adapter",
          "type": "bool"
        },
        {
          "doc": "The required backend type for the adapter.",
          "name": "backend_type",
          "type": "enum.backend_type"
        },
        {
          "doc": "A surface that the adapter must be compatible with.",
          "name": "compatible_surface",
          "optional": true,
          "type": "object.surface"
        }
      ],
      "name": "request_adapter_options",
      "type": "extensible"
    },
    {
      "doc": "Extension for WebXR interop options when requesting an adapter.",
      "extends": ["request_adapter_options"],
      "members": [
        {
          "default": false,
          "doc": "If `true`, requests an adapter compatible with WebXR.",
          "name": "xr_compatible",
          "type": "bool"
        }
      ],
      "name": "request_adapter_WebXR_options",
      "type": "extension"
    },
    {
      "doc": "Describes the layout of a sampler binding.",
      "members": [
        {
          "doc": "The type of the sampler binding. Defaults to @ref WGPUSamplerBindingType_Filtering if `undefined`.",
          "name": "type",
          "type": "enum.sampler_binding_type"
        }
      ],
      "name": "sampler_binding_layout",
      "type": "extensible"
    },
    {
      "doc": "Describes a sampler.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "The address mode for the U coordinate. Defaults to @ref WGPUAddressMode_ClampToEdge.",
          "name": "address_mode_u",
          "type": "enum.address_mode"
        },
        {
          "doc": "The address mode for the V coordinate. Defaults to @ref WGPUAddressMode_ClampToEdge.",
          "name": "address_mode_v",
          "type": "enum.address_mode"
        },
        {
          "doc": "The address mode for the W coordinate. Defaults to @ref WGPUAddressMode_ClampToEdge.",
          "name": "address_mode_w",
          "type": "enum.address_mode"
        },
        {
          "doc": "The magnification filter. Defaults to @ref WGPUFilterMode_Nearest.",
          "name": "mag_filter",
          "type": "enum.filter_mode"
        },
        {
          "doc": "The minification filter. Defaults to @ref WGPUFilterMode_Nearest.",
          "name": "min_filter",
          "type": "enum.filter_mode"
        },
        {
          "doc": "The mipmap filter. Defaults to @ref WGPUMipmapFilterMode_Nearest.",
          "name": "mipmap_filter",
          "type": "enum.mipmap_filter_mode"
        },
        {
          "default": 0,
          "doc": "The minimum level of detail.",
          "name": "lod_min_clamp",
          "type": "float32"
        },
        {
          "default": 32,
          "doc": "The maximum level of detail.",
          "name": "lod_max_clamp",
          "type": "float32"
        },
        {
          "doc": "The comparison function for comparison samplers.",
          "name": "compare",
          "type": "enum.compare_function"
        },
        {
          "default": 1,
          "doc": "The maximum anisotropy value.",
          "name": "max_anisotropy",
          "type": "uint16"
        }
      ],
      "name": "sampler_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a shader module.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        }
      ],
      "name": "shader_module_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Extension for providing SPIR-V shader source code.",
      "extends": ["shader_module_descriptor"],
      "members": [
        {
          "default": 0,
          "doc": "The size of the SPIR-V code in 32-bit words.",
          "name": "code_size",
          "type": "uint32"
        },
        {
          "doc": "A pointer to the SPIR-V code.",
          "name": "code",
          "pointer": "immutable",
          "type": "uint32"
        }
      ],
      "name": "shader_source_SPIRV",
      "type": "extension"
    },
    {
      "doc": "Extension for providing WGSL shader source code.",
      "extends": ["shader_module_descriptor"],
      "members": [
        {
          "doc": "A string containing the WGSL code.",
          "name": "code",
          "type": "string_with_default_empty"
        }
      ],
      "name": "shader_source_WGSL",
      "type": "extension"
    },
    {
      "doc": "Describes the stencil state for a single face of a primitive.",
      "members": [
        {
          "doc": "The comparison function for the stencil test. Defaults to @ref WGPUCompareFunction_Always.",
          "name": "compare",
          "type": "enum.compare_function"
        },
        {
          "doc": "The operation to perform when the stencil test fails. Defaults to @ref WGPUStencilOperation_Keep.",
          "name": "fail_op",
          "type": "enum.stencil_operation"
        },
        {
          "doc": "The operation to perform when the stencil test passes but the depth test fails. Defaults to @ref WGPUStencilOperation_Keep.",
          "name": "depth_fail_op",
          "type": "enum.stencil_operation"
        },
        {
          "doc": "The operation to perform when both stencil and depth tests pass. Defaults to @ref WGPUStencilOperation_Keep.",
          "name": "pass_op",
          "type": "enum.stencil_operation"
        }
      ],
      "name": "stencil_face_state",
      "type": "standalone"
    },
    {
      "doc": "Describes the layout of a storage texture binding.",
      "members": [
        {
          "doc": "The access mode for the storage texture. Defaults to @ref WGPUStorageTextureAccess_WriteOnly.",
          "name": "access",
          "type": "enum.storage_texture_access"
        },
        {
          "doc": "The format of the storage texture.",
          "name": "format",
          "type": "enum.texture_format"
        },
        {
          "doc": "The dimension of the texture view. Defaults to @ref WGPUTextureViewDimension_2D.",
          "name": "view_dimension",
          "type": "enum.texture_view_dimension"
        }
      ],
      "name": "storage_texture_binding_layout",
      "type": "extensible"
    },
    {
      "doc": "Defines the mapping of source texture components to the color channels of a texture view, allowing for reordering or forcing values.",
      "members": [
        {
          "doc": "Specifies the source component or constant value to use for the red channel of the view.",
          "name": "r",
          "type": "enum.component_swizzle"
        },
        {
          "doc": "Specifies the source component or constant value to use for the green channel of the view.",
          "name": "g",
          "type": "enum.component_swizzle"
        },
        {
          "doc": "Specifies the source component or constant value to use for the blue channel of the view.",
          "name": "b",
          "type": "enum.component_swizzle"
        },
        {
          "doc": "Specifies the source component or constant value to use for the alpha channel of the view.",
          "name": "a",
          "type": "enum.component_swizzle"
        }
      ],
      "name": "texture_component_swizzle",
      "type": "standalone"
    },
    {
      "doc": "A list of supported optional features.",
      "free_members": true,
      "members": [
        {
          "doc": "An array of supported feature names.",
          "name": "features",
          "pointer": "immutable",
          "type": "array\u003cenum.feature_name\u003e"
        }
      ],
      "name": "supported_features",
      "type": "standalone"
    },
    {
      "doc": "A list of supported optional instance features.",
      "free_members": true,
      "members": [
        {
          "doc": "An array of supported instance feature names.",
          "name": "features",
          "pointer": "immutable",
          "type": "array\u003cenum.instance_feature_name\u003e"
        }
      ],
      "name": "supported_instance_features",
      "type": "standalone"
    },
    {
      "doc": "A list of supported optional WGSL language features.",
      "free_members": true,
      "members": [
        {
          "doc": "An array of supported WGSL language feature names.",
          "name": "features",
          "pointer": "immutable",
          "type": "array\u003cenum.WGSL_language_feature_name\u003e"
        }
      ],
      "name": "supported_WGSL_language_features",
      "type": "standalone"
    },
    {
      "doc": "Describes the capabilities of a surface for a given adapter.",
      "free_members": true,
      "members": [
        {
          "doc": "The supported texture usages for the surface.",
          "name": "usages",
          "type": "bitflag.texture_usage"
        },
        {
          "doc": "An array of supported texture formats for the surface.",
          "name": "formats",
          "pointer": "immutable",
          "type": "array\u003cenum.texture_format\u003e"
        },
        {
          "doc": "An array of supported present modes for the surface.",
          "name": "present_modes",
          "pointer": "immutable",
          "type": "array\u003cenum.present_mode\u003e"
        },
        {
          "doc": "An array of supported composite alpha modes for the surface.",
          "name": "alpha_modes",
          "pointer": "immutable",
          "type": "array\u003cenum.composite_alpha_mode\u003e"
        }
      ],
      "name": "surface_capabilities",
      "type": "extensible"
    },
    {
      "doc": "Extension for configuring color space and tone mapping for a surface.",
      "members": [
        {
          "doc": "The color space of the surface.",
          "name": "color_space",
          "type": "enum.predefined_color_space"
        },
        {
          "doc": "The tone mapping mode to use.",
          "name": "tone_mapping_mode",
          "type": "enum.tone_mapping_mode"
        }
      ],
      "name": "surface_color_management",
      "type": "extension"
    },
    {
      "doc": "Describes the configuration for a surface.",
      "members": [
        {
          "doc": "The device to use for rendering to the surface.",
          "name": "device",
          "type": "object.device"
        },
        {
          "doc": "The texture format for the surface.",
          "name": "format",
          "type": "enum.texture_format"
        },
        {
          "default": "render_attachment",
          "doc": "The allowed usages for the surface's textures.",
          "name": "usage",
          "type": "bitflag.texture_usage"
        },
        {
          "doc": "The width of the surface's textures.",
          "name": "width",
          "type": "uint32"
        },
        {
          "doc": "The height of the surface's textures.",
          "name": "height",
          "type": "uint32"
        },
        {
          "doc": "An array of additional texture formats for view reinterpretation.",
          "name": "view_formats",
          "pointer": "immutable",
          "type": "array\u003cenum.texture_format\u003e"
        },
        {
          "default": "auto",
          "doc": "The composite alpha mode for the surface.",
          "name": "alpha_mode",
          "type": "enum.composite_alpha_mode"
        },
        {
          "doc": "The presentation mode for the surface.",
          "name": "present_mode",
          "type": "enum.present_mode"
        }
      ],
      "name": "surface_configuration",
      "type": "extensible"
    },
    {
      "doc": "Describes a surface to be created.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        }
      ],
      "name": "surface_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Extension for creating a surface from an Android ANativeWindow.",
      "extends": ["surface_descriptor"],
      "members": [
        {
          "doc": "A pointer to the ANativeWindow.",
          "name": "window",
          "pointer": "mutable",
          "type": "c_void"
        }
      ],
      "name": "surface_source_android_native_window",
      "type": "extension"
    },
    {
      "doc": "Extension for creating a surface from a CAMetalLayer.",
      "extends": ["surface_descriptor"],
      "members": [
        {
          "doc": "A pointer to the CAMetalLayer.",
          "name": "layer",
          "pointer": "mutable",
          "type": "c_void"
        }
      ],
      "name": "surface_source_metal_layer",
      "type": "extension"
    },
    {
      "doc": "Extension for creating a surface from a Wayland wl_surface.",
      "extends": ["surface_descriptor"],
      "members": [
        {
          "doc": "A pointer to the Wayland display.",
          "name": "display",
          "pointer": "mutable",
          "type": "c_void"
        },
        {
          "doc": "A pointer to the Wayland surface.",
          "name": "surface",
          "pointer": "mutable",
          "type": "c_void"
        }
      ],
      "name": "surface_source_wayland_surface",
      "type": "extension"
    },
    {
      "doc": "Extension for creating a surface from a Windows HWND.",
      "extends": ["surface_descriptor"],
      "members": [
        {
          "doc": "The HINSTANCE of the application.",
          "name": "hinstance",
          "pointer": "mutable",
          "type": "c_void"
        },
        {
          "doc": "The HWND of the window.",
          "name": "hwnd",
          "pointer": "mutable",
          "type": "c_void"
        }
      ],
      "name": "surface_source_windows_HWND",
      "type": "extension"
    },
    {
      "doc": "Extension for creating a surface from an XCB window.",
      "extends": ["surface_descriptor"],
      "members": [
        {
          "doc": "A pointer to the XCB connection.",
          "name": "connection",
          "pointer": "mutable",
          "type": "c_void"
        },
        {
          "doc": "The XCB window handle.",
          "name": "window",
          "type": "uint32"
        }
      ],
      "name": "surface_source_XCB_window",
      "type": "extension"
    },
    {
      "doc": "Extension for creating a surface from an Xlib Window.",
      "extends": ["surface_descriptor"],
      "members": [
        {
          "doc": "A pointer to the X11 display.",
          "name": "display",
          "pointer": "mutable",
          "type": "c_void"
        },
        {
          "doc": "The X11 window handle.",
          "name": "window",
          "type": "uint64"
        }
      ],
      "name": "surface_source_xlib_window",
      "type": "extension"
    },
    {
      "doc": "Contains a texture to render to for a surface, along with status information.",
      "members": [
        {
          "doc": "The texture for the current frame.",
          "name": "texture",
          "type": "object.texture"
        },
        {
          "doc": "The status of the texture acquisition.",
          "name": "status",
          "type": "enum.surface_get_current_texture_status"
        }
      ],
      "name": "surface_texture",
      "type": "extensible"
    },
    {
      "doc": "Describes a buffer used in a texel copy operation.",
      "members": [
        {
          "doc": "The layout of the buffer data.",
          "name": "layout",
          "type": "struct.texel_copy_buffer_layout"
        },
        {
          "doc": "The buffer object.",
          "name": "buffer",
          "type": "object.buffer"
        }
      ],
      "name": "texel_copy_buffer_info",
      "type": "standalone"
    },
    {
      "doc": "Describes the layout of texel data within a buffer.",
      "members": [
        {
          "default": 0,
          "doc": "The offset in bytes from the beginning of the buffer.",
          "name": "offset",
          "type": "uint64"
        },
        {
          "default": "constant.copy_stride_undefined",
          "doc": "The number of bytes per row of texel data.",
          "name": "bytes_per_row",
          "type": "uint32"
        },
        {
          "default": "constant.copy_stride_undefined",
          "doc": "The number of rows per image slice.",
          "name": "rows_per_image",
          "type": "uint32"
        }
      ],
      "name": "texel_copy_buffer_layout",
      "type": "standalone"
    },
    {
      "doc": "Describes a texture used in a texel copy operation.",
      "members": [
        {
          "doc": "The texture object.",
          "name": "texture",
          "type": "object.texture"
        },
        {
          "default": 0,
          "doc": "The mipmap level to use.",
          "name": "mip_level",
          "type": "uint32"
        },
        {
          "doc": "The origin of the copy region in the texture.",
          "name": "origin",
          "type": "struct.origin_3D"
        },
        {
          "doc": "The texture aspect to use. Defaults to @ref WGPUTextureAspect_All.",
          "name": "aspect",
          "type": "enum.texture_aspect"
        }
      ],
      "name": "texel_copy_texture_info",
      "type": "standalone"
    },
    {
      "doc": "Describes the layout of a texture binding.",
      "members": [
        {
          "doc": "The sample type of the texture. Defaults to @ref WGPUTextureSampleType_Float.",
          "name": "sample_type",
          "type": "enum.texture_sample_type"
        },
        {
          "doc": "The dimension of the texture view. Defaults to @ref WGPUTextureViewDimension_2D.",
          "name": "view_dimension",
          "type": "enum.texture_view_dimension"
        },
        {
          "default": false,
          "doc": "Specifies if the texture is multisampled.",
          "name": "multisampled",
          "type": "bool"
        }
      ],
      "name": "texture_binding_layout",
      "type": "extensible"
    },
    {
      "doc": "An extension chained to a texture view descriptor to define a custom component swizzle. This allows remapping or forcing specific values for the R, G, B, and A channels when accessing the texture view.",
      "extends": ["struct.texture_view_descriptor"],
      "members": [
        {
          "doc": "The swizzle configuration specifying the source component or constant value for each channel of the texture view.",
          "name": "swizzle",
          "type": "struct.texture_component_swizzle"
        }
      ],
      "name": "texture_component_swizzle_descriptor",
      "type": "extension"
    },
    {
      "doc": "Describes a texture to be created.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "default": "none",
          "doc": "The allowed usages for the texture.",
          "name": "usage",
          "type": "bitflag.texture_usage"
        },
        {
          "doc": "The dimension of the texture. Defaults to @ref WGPUTextureDimension_2D.",
          "name": "dimension",
          "type": "enum.texture_dimension"
        },
        {
          "doc": "The size of the texture.",
          "name": "size",
          "type": "struct.extent_3D"
        },
        {
          "doc": "The format of the texture.",
          "name": "format",
          "type": "enum.texture_format"
        },
        {
          "default": 1,
          "doc": "The number of mipmap levels.",
          "name": "mip_level_count",
          "type": "uint32"
        },
        {
          "default": 1,
          "doc": "The number of samples for multisampling.",
          "name": "sample_count",
          "type": "uint32"
        },
        {
          "doc": "An array of additional texture formats for view reinterpretation.",
          "name": "view_formats",
          "pointer": "immutable",
          "type": "array\u003cenum.texture_format\u003e"
        }
      ],
      "name": "texture_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a texture view.",
      "members": [
        {
          "doc": "A human-readable label for debugging.",
          "name": "label",
          "type": "string_with_default_empty"
        },
        {
          "doc": "The format of the texture view.",
          "name": "format",
          "type": "enum.texture_format"
        },
        {
          "doc": "The dimension of the texture view.",
          "name": "dimension",
          "type": "enum.texture_view_dimension"
        },
        {
          "default": 0,
          "doc": "The base mipmap level for the view.",
          "name": "base_mip_level",
          "type": "uint32"
        },
        {
          "default": "constant.mip_level_count_undefined",
          "doc": "The number of mipmap levels in the view.",
          "name": "mip_level_count",
          "type": "uint32"
        },
        {
          "default": 0,
          "doc": "The base array layer for the view.",
          "name": "base_array_layer",
          "type": "uint32"
        },
        {
          "default": "constant.array_layer_count_undefined",
          "doc": "The number of array layers in the view.",
          "name": "array_layer_count",
          "type": "uint32"
        },
        {
          "doc": "The texture aspect for the view. Defaults to @ref WGPUTextureAspect_All.",
          "name": "aspect",
          "type": "enum.texture_aspect"
        },
        {
          "default": "none",
          "doc": "The usage of the texture view.",
          "name": "usage",
          "type": "bitflag.texture_usage"
        }
      ],
      "name": "texture_view_descriptor",
      "type": "extensible"
    },
    {
      "doc": "Describes a single vertex attribute.",
      "members": [
        {
          "doc": "The format of the vertex attribute data.",
          "name": "format",
          "type": "enum.vertex_format"
        },
        {
          "doc": "The offset in bytes from the beginning of the vertex.",
          "name": "offset",
          "type": "uint64"
        },
        {
          "doc": "The shader location for the attribute.",
          "name": "shader_location",
          "type": "uint32"
        }
      ],
      "name": "vertex_attribute",
      "type": "extensible"
    },
    {
      "doc": "Describes the layout of a single vertex buffer.",
      "members": [
        {
          "doc": "The step mode for the vertex buffer. Defaults to @ref WGPUVertexStepMode_Vertex.",
          "name": "step_mode",
          "type": "enum.vertex_step_mode"
        },
        {
          "doc": "The stride in bytes between vertices in the buffer.",
          "name": "array_stride",
          "type": "uint64"
        },
        {
          "doc": "An array of vertex attributes sourced from this buffer.",
          "name": "attributes",
          "pointer": "immutable",
          "type": "array\u003cstruct.vertex_attribute\u003e"
        }
      ],
      "name": "vertex_buffer_layout",
      "type": "extensible"
    },
    {
      "doc": "Describes the vertex shader stage of a render pipeline.",
      "members": [
        {
          "doc": "The shader module containing the vertex shader.",
          "name": "module",
          "type": "object.shader_module"
        },
        {
          "doc": "The name of the entry point function in the shader module.",
          "name": "entry_point",
          "type": "nullable_string"
        },
        {
          "doc": "An array of pipeline-overridable constants.",
          "name": "constants",
          "pointer": "immutable",
          "type": "array\u003cstruct.constant_entry\u003e"
        },
        {
          "doc": "An array of vertex buffer layouts.",
          "name": "buffers",
          "pointer": "immutable",
          "type": "array\u003cstruct.vertex_buffer_layout\u003e"
        }
      ],
      "name": "vertex_state",
      "type": "extensible"
    }
  ],
  "typedefs": []
}
